/**
 * Doobie-Style SQL in typesugar
 *
 * This example demonstrates the full Doobie-like capabilities:
 *
 * 1. Meta/Get/Put typeclasses with @derive(Meta)
 * 2. Type-safe fragments with sql$
 * 3. Composable query building
 * 4. ConnectionIO for pure database operations
 * 5. Transaction handling
 * 6. Zero-cost specialization
 */

import {
  // Core types
  TypedFragment,
  TypedQuery,
  TypedUpdate,
  
  // Meta typeclasses
  Meta,
  Read,
  Write,
  SqlRow,
  stringMeta,
  numberMeta,
  booleanMeta,
  dateMeta,
  nullable,
  optional,
  
  // Fragment combinators
  andTyped,
  orTyped,
  commasTyped,
  inListTyped,
  valuesTyped,
  valuesManyTyped,
  setTyped,
  whenTyped,
  whereAndTyped,
  
  // ConnectionIO
  ConnectionIO,
  Transactor,
  sequence,
  traverse,
  when,
  
  // Query builder
  select,
} from "../src/index.js";

import { specialize } from "@typesugar/macros";

// ============================================================================
// 1. Define Schema Types with @derive(Meta)
// ============================================================================

/**
 * @derive(Meta)
 * User table schema - automatically generates UserMeta
 */
interface User {
  id: number;
  name: string;
  email: string;
  /** @column("is_active") */
  isActive: boolean;
  /** @column("created_at") */
  createdAt: Date;
  /** @column("updated_at") */
  updatedAt: Date | null;
}

// Generated by @derive(Meta) macro:
const UserMeta: Read<User> & Write<User> = {
  _tag: "Meta",
  columns: ["id", "name", "email", "is_active", "created_at", "updated_at"],
  
  read: (row: SqlRow): User | null => ({
    id: numberMeta.unsafeGet(row.id),
    name: stringMeta.unsafeGet(row.name),
    email: stringMeta.unsafeGet(row.email),
    isActive: booleanMeta.unsafeGet(row.is_active),
    createdAt: dateMeta.unsafeGet(row.created_at),
    updatedAt: nullable(dateMeta).get(row.updated_at),
  }),
  
  unsafeRead: (row: SqlRow): User => UserMeta.read(row)!,
  
  write: (user: User): readonly unknown[] => [
    numberMeta.put(user.id),
    stringMeta.put(user.name),
    stringMeta.put(user.email),
    booleanMeta.put(user.isActive),
    dateMeta.put(user.createdAt),
    nullable(dateMeta).put(user.updatedAt),
  ],
};

/**
 * @derive(Meta)
 * Audit log for tracking changes
 */
interface AuditLog {
  id: number;
  userId: number;
  action: string;
  timestamp: Date;
}

const AuditLogMeta: Read<AuditLog> & Write<AuditLog> = {
  _tag: "Meta",
  columns: ["id", "user_id", "action", "timestamp"],
  
  read: (row: SqlRow): AuditLog | null => ({
    id: numberMeta.unsafeGet(row.id),
    userId: numberMeta.unsafeGet(row.user_id),
    action: stringMeta.unsafeGet(row.action),
    timestamp: dateMeta.unsafeGet(row.timestamp),
  }),
  
  unsafeRead: (row: SqlRow): AuditLog => AuditLogMeta.read(row)!,
  
  write: (log: AuditLog): readonly unknown[] => [
    numberMeta.put(log.id),
    numberMeta.put(log.userId),
    stringMeta.put(log.action),
    dateMeta.put(log.timestamp),
  ],
};

// ============================================================================
// 2. Type-Safe Fragment Building with sql$
// ============================================================================

// In the actual implementation, sql$ is a macro that infers types.
// Here we show the intended usage pattern:

function sql$<R = void>(
  strings: TemplateStringsArray,
  ...values: unknown[]
): TypedFragment<unknown[], R> {
  const segments = [...strings];
  const params = values.map(v => ({ value: v }));
  return new TypedFragment(segments, params);
}

// Basic query - result type inferred from SELECT
const selectAllUsers = sql$<User>`
  SELECT id, name, email, is_active, created_at, updated_at 
  FROM users
`;

// Parameterized fragment
const byId = (id: number) => sql$`WHERE id = ${id}`;
const byEmail = (email: string) => sql$`WHERE email = ${email}`;
const activeOnly = sql$`AND is_active = true`;

// ============================================================================
// 3. Composable Query Building (Doobie-style)
// ============================================================================

/**
 * Find user by ID - demonstrates fragment composition
 */
function findUserById(id: number): TypedQuery<[number], User> {
  const query = selectAllUsers.append(byId(id));
  return query.query();
}

/**
 * Find users by multiple IDs - demonstrates IN clause
 */
function findUsersByIds(ids: number[]): TypedQuery<number[], User> {
  const inClause = inListTyped<number>("id", ids);
  const query = selectAllUsers.append(
    new TypedFragment(["WHERE "], []).append(inClause)
  );
  return query.query() as TypedQuery<number[], User>;
}

/**
 * Dynamic query with optional filters - Doobie's powerful pattern
 */
function searchUsers(
  nameFilter?: string,
  emailFilter?: string,
  activeFilter?: boolean,
): TypedQuery<unknown[], User> {
  // Build WHERE clause from optional conditions
  const whereClause = whereAndTyped(
    nameFilter ? sql$`name ILIKE ${`%${nameFilter}%`}` : undefined,
    emailFilter ? sql$`email ILIKE ${`%${emailFilter}%`}` : undefined,
    activeFilter !== undefined ? sql$`is_active = ${activeFilter}` : undefined,
  );
  
  const query = selectAllUsers.append(whereClause);
  return query.query() as TypedQuery<unknown[], User>;
}

/**
 * Complex query with joins
 */
const usersWithRecentActivity = sql$<User & { lastAction: string }>`
  SELECT u.*, a.action as last_action
  FROM users u
  LEFT JOIN audit_log a ON a.user_id = u.id
  WHERE a.timestamp > ${new Date(Date.now() - 86400000)}
  ORDER BY a.timestamp DESC
`;

// ============================================================================
// 4. Insert/Update Operations
// ============================================================================

/**
 * Insert a single user - type-safe with Meta
 */
function insertUser(user: Omit<User, 'id'>): TypedUpdate<unknown[]> {
  const columns = UserMeta.columns.filter(c => c !== 'id').join(', ');
  const values = valuesTyped(UserMeta, user as User);
  
  const fragment = new TypedFragment<unknown[], void>(
    [`INSERT INTO users (${columns}) VALUES `],
    [],
  ).append(values);
  
  return fragment.update();
}

/**
 * Batch insert - efficiently insert multiple rows
 */
function insertUsers(users: Omit<User, 'id'>[]): TypedUpdate<unknown[]> {
  const columns = UserMeta.columns.filter(c => c !== 'id').join(', ');
  const values = valuesManyTyped(UserMeta, users as User[]);
  
  const fragment = new TypedFragment<unknown[], void>(
    [`INSERT INTO users (${columns}) VALUES `],
    [],
  ).append(values);
  
  return fragment.update();
}

/**
 * Update user - partial updates with SET clause
 */
function updateUser(id: number, updates: Partial<User>): TypedUpdate<unknown[]> {
  const setClause = setTyped(UserMeta, updates);
  
  const fragment = new TypedFragment<unknown[], void>(
    ["UPDATE users SET "],
    [],
  ).append(setClause).append(sql$` WHERE id = ${id}`);
  
  return fragment.update();
}

// ============================================================================
// 5. ConnectionIO — Pure Database Operations
// ============================================================================

/**
 * Find user as ConnectionIO program
 */
function findUserIO(id: number): ConnectionIO<User | null> {
  return ConnectionIO.query(findUserById(id), UserMeta);
}

/**
 * Log action as ConnectionIO
 */
function logAction(userId: number, action: string): ConnectionIO<void> {
  const log: AuditLog = {
    id: 0, // Will be generated
    userId,
    action,
    timestamp: new Date(),
  };
  
  const fragment = new TypedFragment<unknown[], void>(
    ["INSERT INTO audit_log (user_id, action, timestamp) VALUES "],
    [],
  ).append(valuesTyped(AuditLogMeta, log));
  
  return ConnectionIO.execute(fragment.update()).map(() => undefined);
}

/**
 * Complex transactional operation — Doobie's power!
 *
 * This demonstrates how ConnectionIO composes:
 * 1. Find the user
 * 2. If found, log the access
 * 3. Return the user
 *
 * All in a single transaction!
 */
function getUserWithAudit(userId: number): ConnectionIO<User | null> {
  return findUserIO(userId).flatMap((user) => {
    if (user === null) {
      return ConnectionIO.pure(null);
    }
    
    return logAction(userId, "USER_ACCESSED")
      .map(() => user);
  });
}

/**
 * Batch operation with error handling
 */
function createUsersWithRollback(
  users: Omit<User, 'id'>[],
): ConnectionIO<number[]> {
  // Insert each user and collect generated IDs
  return traverse(users, (user) =>
    ConnectionIO.executeWithKeys(insertUser(user), ["id"])
      .map((rows) => rows[0].id as number),
  );
}

/**
 * Conditional execution
 */
function maybeDeactivateUser(
  userId: number,
  shouldDeactivate: boolean,
): ConnectionIO<void> {
  return when(
    shouldDeactivate,
    ConnectionIO.execute(
      updateUser(userId, { isActive: false }),
    ).map(() => undefined),
  );
}

// ============================================================================
// 6. Zero-Cost Specialization
// ============================================================================

/**
 * Generic query execution with Meta
 *
 * This would be specialized at compile time to inline the Meta operations.
 */
async function queryOne<A>(
  meta: Read<A>,
  query: TypedQuery<unknown[], A>,
  transactor: Transactor,
): Promise<A | null> {
  const cio = ConnectionIO.query(query, meta);
  return transactor.run(cio);
}

// Specialized version (what the macro produces):
// const queryUser = specialize(queryOne, UserMeta);
// Compiles to:
// async function queryUser(query, transactor) {
//   const { sql, params } = query.toSql();
//   const rows = await transactor.run(ConnectionIO.raw(sql, params));
//   if (rows.length === 0) return null;
//   const row = rows[0];
//   return {
//     id: row.id as number,
//     name: row.name as string,
//     email: row.email as string,
//     isActive: row.is_active as boolean,
//     createdAt: new Date(row.created_at as string),
//     updatedAt: row.updated_at ? new Date(row.updated_at as string) : null,
//   };
// }

// ============================================================================
// 7. Query Builder DSL
// ============================================================================

/**
 * Type-safe query builder (alternative to fragments)
 */
function buildUserQuery(filters: {
  name?: string;
  email?: string;
  active?: boolean;
  limit?: number;
}) {
  let builder = select<User>("id", "name", "email", "is_active", "created_at", "updated_at")
    .from("users");
  
  if (filters.name) {
    builder = builder.where(sql$`name ILIKE ${`%${filters.name}%`}`);
  }
  
  if (filters.email) {
    builder = builder.andWhere(sql$`email ILIKE ${`%${filters.email}%`}`);
  }
  
  if (filters.active !== undefined) {
    builder = builder.andWhere(sql$`is_active = ${filters.active}`);
  }
  
  if (filters.limit) {
    builder = builder.limit(filters.limit);
  }
  
  return builder.build();
}

// ============================================================================
// Usage Example
// ============================================================================

async function main() {
  // Create a mock transactor
  const mockConnection = {
    query: async (sql: string, params: unknown[]) => {
      console.log("Query:", sql);
      console.log("Params:", params);
      return [
        {
          id: 1,
          name: "Alice",
          email: "alice@example.com",
          is_active: true,
          created_at: new Date().toISOString(),
          updated_at: null,
        },
      ];
    },
    execute: async (sql: string, params: unknown[]) => {
      console.log("Execute:", sql);
      console.log("Params:", params);
      return 1;
    },
    begin: async () => console.log("BEGIN"),
    commit: async () => console.log("COMMIT"),
    rollback: async () => console.log("ROLLBACK"),
  };

  const transactor = Transactor.fromConnection(mockConnection);

  // 1. Simple query
  console.log("\n--- Find User by ID ---");
  const user = await transactor.run(findUserIO(1));
  console.log("Found:", user);

  // 2. Transactional operation
  console.log("\n--- Get User with Audit ---");
  const auditedUser = await transactor.transact(getUserWithAudit(1));
  console.log("Audited:", auditedUser);

  // 3. Dynamic query building
  console.log("\n--- Search Users ---");
  const searchQuery = searchUsers("Ali", undefined, true);
  const { sql: searchSql, params: searchParams } = searchQuery.toSql();
  console.log("SQL:", searchSql);
  console.log("Params:", searchParams);

  // 4. Query builder DSL
  console.log("\n--- Query Builder ---");
  const built = buildUserQuery({ name: "Bob", active: true, limit: 10 });
  console.log("Built SQL:", built.sql);
  console.log("Built Params:", built.params);

  // 5. Batch insert
  console.log("\n--- Batch Insert ---");
  const newUsers = [
    { name: "Bob", email: "bob@example.com", isActive: true, createdAt: new Date(), updatedAt: null },
    { name: "Charlie", email: "charlie@example.com", isActive: true, createdAt: new Date(), updatedAt: null },
  ] as Omit<User, 'id'>[];
  
  const insertQuery = insertUsers(newUsers);
  console.log("Insert SQL:", insertQuery.toSql());
}

main().catch(console.error);
