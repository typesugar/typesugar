/**
 * Proof Certificates (Coq-inspired)
 *
 * Structured proof explanations showing why a condition was proven
 * (or why it failed). Inspired by Coq's proof terms and tactics.
 *
 * Each proof certificate contains:
 * - The goal being proven
 * - The assumptions/facts used
 * - The proof steps (tactic applications)
 * - Whether the proof succeeded
 * - Failure reason if not
 *
 * This enables:
 * - Human-readable proof explanations
 * - Debugging of failed proofs
 * - Proof auditing and inspection
 * - Integration with documentation
 */

import type { TypeFact } from "./type-facts.js";

/**
 * A single step in a proof, corresponding to a tactic application in Coq.
 */
export interface ProofStep {
  /** The rule or tactic applied (e.g., "positive_implies_non_negative") */
  rule: string;
  /** Human-readable description of what this step does */
  description: string;
  /** Subgoals generated by this step (empty if terminal) */
  subgoals: string[];
  /** The facts/assumptions used in this step */
  usedFacts: TypeFact[];
  /** Justification for why this step is valid */
  justification: string;
}

/**
 * The proof method that succeeded (or was attempted).
 */
export type ProofMethod =
  | "constant" // Compile-time constant evaluation
  | "type" // Type-based deduction from Refined types
  | "algebra" // Algebraic proof rules
  | "linear" // Linear arithmetic solver (Fourier-Motzkin)
  | "plugin"; // External prover plugin

/**
 * A proof certificate — structured record of a proof attempt.
 *
 * Unlike ProofResult which just reports success/failure,
 * ProofCertificate includes the full proof trace.
 */
export interface ProofCertificate {
  /** The goal/condition being proven */
  goal: string;
  /** Whether the proof succeeded */
  proven: boolean;
  /** Which proof method succeeded (if any) */
  method?: ProofMethod;
  /** The proof steps (tactic trace) */
  steps: ProofStep[];
  /** The assumptions/facts available */
  assumptions: TypeFact[];
  /** Human-readable summary of the proof */
  summary?: string;
  /** Why the proof failed (if !proven) */
  failureReason?: string;
  /** Time taken for proof (milliseconds) */
  timeMs?: number;
}

/**
 * Create an empty proof certificate for a goal.
 */
export function createCertificate(goal: string, assumptions: TypeFact[]): ProofCertificate {
  return {
    goal,
    proven: false,
    steps: [],
    assumptions: [...assumptions],
  };
}

/**
 * Mark a certificate as proven with a successful step.
 */
export function succeedCertificate(
  cert: ProofCertificate,
  method: ProofMethod,
  step: ProofStep
): ProofCertificate {
  return {
    ...cert,
    proven: true,
    method,
    steps: [...cert.steps, step],
    summary: `Proven by ${method}: ${step.justification}`,
  };
}

/**
 * Mark a certificate as failed.
 */
export function failCertificate(cert: ProofCertificate, reason: string): ProofCertificate {
  return {
    ...cert,
    proven: false,
    failureReason: reason,
  };
}

/**
 * Add an intermediate step to a certificate.
 */
export function addStep(cert: ProofCertificate, step: ProofStep): ProofCertificate {
  return {
    ...cert,
    steps: [...cert.steps, step],
  };
}

/**
 * Create a simple proof step.
 */
export function createStep(
  rule: string,
  description: string,
  justification: string,
  usedFacts: TypeFact[] = [],
  subgoals: string[] = []
): ProofStep {
  return {
    rule,
    description,
    subgoals,
    usedFacts,
    justification,
  };
}

/**
 * Format a proof certificate as a human-readable string.
 */
export function formatCertificate(cert: ProofCertificate): string {
  const lines: string[] = [];

  lines.push(`Proof Certificate`);
  lines.push(`─────────────────`);
  lines.push(`Goal: ${cert.goal}`);
  lines.push(`Status: ${cert.proven ? "✓ PROVEN" : "✗ UNPROVEN"}`);

  if (cert.method) {
    lines.push(`Method: ${cert.method}`);
  }

  if (cert.assumptions.length > 0) {
    lines.push(`\nAssumptions:`);
    for (const fact of cert.assumptions) {
      lines.push(`  ${fact.variable}: ${fact.predicate}`);
    }
  }

  if (cert.steps.length > 0) {
    lines.push(`\nProof Steps:`);
    for (let i = 0; i < cert.steps.length; i++) {
      const step = cert.steps[i];
      lines.push(`  ${i + 1}. ${step.rule}`);
      lines.push(`     ${step.description}`);
      if (step.usedFacts && step.usedFacts.length > 0) {
        lines.push(`     Using: ${step.usedFacts.map((f) => f.predicate).join(", ")}`);
      }
      if (step.subgoals && step.subgoals.length > 0) {
        lines.push(`     Subgoals: ${step.subgoals.join(", ")}`);
      }
    }
  }

  if (cert.summary) {
    lines.push(`\nSummary: ${cert.summary}`);
  }

  if (cert.failureReason) {
    lines.push(`\nFailure: ${cert.failureReason}`);
  }

  if (cert.timeMs !== undefined) {
    lines.push(`\nTime: ${cert.timeMs.toFixed(2)}ms`);
  }

  return lines.join("\n");
}

/**
 * Convert a ProofCertificate to a simple ProofResult.
 * For backwards compatibility with code expecting ProofResult.
 */
export function certificateToResult(cert: ProofCertificate): {
  proven: boolean;
  method?: ProofMethod;
  reason?: string;
} {
  return {
    proven: cert.proven,
    method: cert.method,
    reason: cert.summary ?? cert.failureReason,
  };
}
