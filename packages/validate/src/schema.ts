/**
 * Schema Typeclass - Universal Validation Interface
 *
 * A typeclass that abstracts over validation libraries (Zod, Valibot, ArkType, native).
 * Enables library-agnostic validation code with zero-cost specialization.
 *
 * ## Zero-Cost Philosophy
 *
 * When combined with `specialize()`, the Schema dictionary is eliminated at compile time.
 * Generic validation code compiles down to direct library-specific calls with no overhead.
 *
 * @example
 * ```typescript
 * // Library-agnostic validation function
 * function processBody<F, A>(S: Schema<F>, schema: $<F, A>, data: unknown): A {
 *   return S.parse(schema, data);
 * }
 *
 * // After specialize(), this becomes:
 * function processBody_zod(schema: ZodType<User>, data: unknown): User {
 *   return schema.parse(data);
 * }
 * ```
 *
 * @module @typesugar/validate/schema
 */

import type { $ } from "@typesugar/type-system";
import type { ValidatedNel } from "@typesugar/fp";
import { Valid, invalidNel } from "@typesugar/fp";
import type { ValidationError } from "./types.js";

// ============================================================================
// Schema Typeclass Interface
// ============================================================================

/**
 * Schema typeclass for validation libraries.
 *
 * `F` is a type-level function representing the schema type constructor.
 * For example:
 * - `ZodF` where `$<ZodF, User>` = `ZodType<User>`
 * - `ValibotF` where `$<ValibotF, User>` = `BaseSchema<User>`
 * - `ValidatorF` where `$<ValidatorF, User>` = `(x: unknown) => x is User`
 */
export interface Schema<F> {
  /**
   * Parse data and return the validated value, or throw on failure.
   */
  readonly parse: <A>(schema: $<F, A>, data: unknown) => A;

  /**
   * Parse data and return a `ValidatedNel` with accumulated errors.
   */
  readonly safeParse: <A>(schema: $<F, A>, data: unknown) => ValidatedNel<ValidationError, A>;
}

// ============================================================================
// Native Validator Types
// ============================================================================

/**
 * Type-level function marker for native validators.
 *
 * Note: TypeScript's HKT encoding via indexed access types doesn't handle
 * type predicates well. We use a phantom marker type here and provide
 * specialized `NativeSchema` interface for proper typing.
 */
export interface ValidatorF {
  readonly _brand: "ValidatorF";
}

/**
 * A type guard function that validates unknown data as type A.
 */
export type Validator<A> = (value: unknown) => value is A;

/**
 * Specialized Schema interface for native validators.
 *
 * This provides proper typing for validators since the generic HKT encoding
 * doesn't work well with TypeScript's type predicate syntax.
 */
export interface NativeSchema {
  readonly parse: <A>(validator: Validator<A>, data: unknown) => A;
  readonly safeParse: <A>(
    validator: Validator<A>,
    data: unknown
  ) => ValidatedNel<ValidationError, A>;
}

/**
 * Type-level function for assertion validators.
 * `$<AssertF, A>` resolves to an assertion function `(x: unknown) => A`.
 */
export interface AssertF {
  _: (value: unknown) => this["_"];
}

// ============================================================================
// Native Schema Instance
// ============================================================================

/**
 * Schema instance for native typesugar validators (is<T>()).
 *
 * This works with validators generated by the `is<T>()` macro.
 */
export const nativeSchema: NativeSchema = {
  parse: <A>(validator: Validator<A>, data: unknown): A => {
    if (validator(data)) {
      return data;
    }
    throw new Error("Validation failed");
  },

  safeParse: <A>(validator: Validator<A>, data: unknown): ValidatedNel<ValidationError, A> => {
    if (validator(data)) {
      return Valid(data);
    }
    return invalidNel({ path: "$", message: "Validation failed" });
  },
};

// ============================================================================
// Derived Operations (Generic HKT)
// ============================================================================

/**
 * Parse or return a default value.
 */
export function parseOrElse<F>(
  S: Schema<F>
): <A>(schema: $<F, A>, data: unknown, fallback: A) => A {
  return (schema, data, fallback) => {
    const result = S.safeParse(schema, data);
    return result._tag === "Valid" ? result.value : fallback;
  };
}

/**
 * Parse and map the result.
 */
export function parseMap<F>(
  S: Schema<F>
): <A, B>(schema: $<F, A>, data: unknown, f: (a: A) => B) => B {
  return (schema, data, f) => f(S.parse(schema, data));
}

/**
 * Chain two parsers - parse with the first, then parse the result with the second.
 */
export function parseChain<F>(
  S: Schema<F>
): <A, B>(schemaA: $<F, A>, schemaB: $<F, B>, data: unknown) => B {
  return (schemaA, schemaB, data) => {
    const a = S.parse(schemaA, data);
    return S.parse(schemaB, a);
  };
}

/**
 * Validate multiple values with the same schema.
 */
export function parseAll<F>(S: Schema<F>): <A>(schema: $<F, A>, data: unknown[]) => A[] {
  return (schema, data) => data.map((d) => S.parse(schema, d));
}

/**
 * Safely validate multiple values, collecting all errors.
 */
export function safeParseAll<F>(
  S: Schema<F>
): <A>(schema: $<F, A>, data: unknown[]) => ValidatedNel<ValidationError, A[]> {
  return <A>(schema: $<F, A>, data: unknown[]) => {
    const results = data.map((d) => S.safeParse(schema, d));
    const errors: ValidationError[] = [];
    const values: A[] = [];

    for (const result of results) {
      if (result._tag === "Valid") {
        values.push(result.value);
      } else {
        // Access the NonEmptyList error
        const nel = result.error;
        errors.push(nel.head);
        // Traverse the tail (which is a List)
        let current = nel.tail;
        while (current._tag === "Cons") {
          errors.push(current.head);
          current = current.tail;
        }
      }
    }

    if (errors.length > 0) {
      return invalidNel(errors[0]);
    }

    return Valid(values);
  };
}

// ============================================================================
// Derived Operations (Native Validators)
// ============================================================================

/**
 * Parse or return a default value (native validators).
 */
export function nativeParseOrElse(
  S: NativeSchema
): <A>(validator: Validator<A>, data: unknown, fallback: A) => A {
  return (validator, data, fallback) => {
    const result = S.safeParse(validator, data);
    return result._tag === "Valid" ? result.value : fallback;
  };
}

/**
 * Parse and map the result (native validators).
 */
export function nativeParseMap(
  S: NativeSchema
): <A, B>(validator: Validator<A>, data: unknown, f: (a: A) => B) => B {
  return (validator, data, f) => f(S.parse(validator, data));
}

/**
 * Validate multiple values with the same validator (native validators).
 */
export function nativeParseAll(
  S: NativeSchema
): <A>(validator: Validator<A>, data: unknown[]) => A[] {
  return (validator, data) => data.map((d) => S.parse(validator, d));
}

/**
 * Safely validate multiple values, collecting all errors (native validators).
 */
export function nativeSafeParseAll(
  S: NativeSchema
): <A>(validator: Validator<A>, data: unknown[]) => ValidatedNel<ValidationError, A[]> {
  return <A>(validator: Validator<A>, data: unknown[]) => {
    const results = data.map((d) => S.safeParse(validator, d));
    const errors: ValidationError[] = [];
    const values: A[] = [];

    for (const result of results) {
      if (result._tag === "Valid") {
        values.push(result.value);
      } else {
        const nel = result.error;
        errors.push(nel.head);
        let current = nel.tail;
        while (current._tag === "Cons") {
          errors.push(current.head);
          current = current.tail;
        }
      }
    }

    if (errors.length > 0) {
      return invalidNel(errors[0]);
    }

    return Valid(values);
  };
}

// ============================================================================
// Instance Creator
// ============================================================================

/**
 * Create a Schema instance from parse and safeParse functions.
 */
export function makeSchema<F>(
  parse: <A>(schema: $<F, A>, data: unknown) => A,
  safeParse: <A>(schema: $<F, A>, data: unknown) => ValidatedNel<ValidationError, A>
): Schema<F> {
  return { parse, safeParse };
}

/**
 * Create a NativeSchema instance from parse and safeParse functions.
 */
export function makeNativeSchema(
  parse: <A>(validator: Validator<A>, data: unknown) => A,
  safeParse: <A>(validator: Validator<A>, data: unknown) => ValidatedNel<ValidationError, A>
): NativeSchema {
  return { parse, safeParse };
}
