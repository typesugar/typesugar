{"version":3,"sources":["../src/index.ts","../src/api.ts","../src/macros.ts"],"sourcesContent":["export * from \"./api.js\";\n\nimport { register } from \"./macros.js\";\n\n// Auto-register when this module is imported by the transformer\nregister();\n","export interface TransformConfig<From, To> {\n  /**\n   * Rename fields from the source to the target.\n   * Key: the target field name.\n   * Value: the source field name.\n   */\n  rename?: { [K in keyof To]?: keyof From };\n\n  /**\n   * Compute target fields dynamically using a function.\n   * Key: the target field name.\n   * Value: a function that takes the source object and returns the target field value.\n   */\n  compute?: { [K in keyof To]?: (src: From) => To[K] };\n\n  /**\n   * Provide constant values for target fields.\n   * Key: the target field name.\n   * Value: the constant value.\n   */\n  const?: { [K in keyof To]?: To[K] };\n\n  /**\n   * Ignore unmapped target fields or unused source fields.\n   */\n  ignore?: {\n    source?: (keyof From)[];\n    target?: (keyof To)[];\n  };\n}\n\n/**\n * Transforms an object of type `From` into an object of type `To` at compile time.\n *\n * This function is evaluated by the typemacro transformer and replaced with a direct\n * object literal, resulting in zero runtime overhead.\n *\n * @param source The source object to transform.\n * @param config Optional configuration for renaming, computing, and providing constants.\n * @returns The transformed object.\n */\nexport function transformInto<From, To>(source: From, config?: TransformConfig<From, To>): To {\n  throw new Error(\n    \"transformInto() was called at runtime. \" +\n      \"This indicates the typesugar transformer is not configured correctly. \" +\n      \"Please ensure your build tool is configured to use the typesugar transformer.\"\n  );\n}\n","import * as ts from \"typescript\";\nimport { defineExpressionMacro, globalRegistry, MacroContext } from \"@typesugar/core\";\n\nexport const transformIntoMacro = defineExpressionMacro({\n  name: \"transformInto\",\n  module: \"@typesugar/mapper\",\n  description: \"Zero-cost compile-time object mapping\",\n\n  expand(\n    ctx: MacroContext,\n    callExpr: ts.CallExpression,\n    args: readonly ts.Expression[]\n  ): ts.Expression {\n    if (args.length < 1) {\n      ctx.reportError(callExpr, \"transformInto expects at least 1 argument\");\n      return callExpr;\n    }\n\n    const sourceExpr = args[0];\n    const configExpr = args[1];\n\n    // 1. Get From and To types\n    const fromType = ctx.getTypeOf(sourceExpr);\n    // The return type of transformInto<From, To> is To\n    const toType = ctx.getTypeOf(callExpr);\n\n    // 2. Parse config\n    const config = parseConfig(ctx, configExpr);\n\n    // 3. Get properties\n    const fromProps = ctx.getPropertiesOfType(fromType);\n    const toProps = ctx.getPropertiesOfType(toType);\n\n    const fromPropNames = new Set(fromProps.map((p) => p.name));\n\n    const resultProperties: ts.ObjectLiteralElementLike[] = [];\n\n    // Avoid duplicate evaluation of source expression if it's complex\n    let sourceIdent = sourceExpr;\n    let needsTempVar = false;\n    let tempName: ts.Identifier | undefined;\n\n    if (!ts.isIdentifier(sourceExpr) && !isSimpleLiteral(sourceExpr)) {\n      needsTempVar = true;\n      tempName = ctx.generateUniqueName(\"src\");\n      sourceIdent = tempName;\n    }\n\n    // 4. Map fields\n    for (const toProp of toProps) {\n      const name = toProp.name;\n\n      // Is it a constant?\n      if (config.const.has(name)) {\n        resultProperties.push(ctx.factory.createPropertyAssignment(name, config.const.get(name)!));\n        continue;\n      }\n\n      // Is it computed?\n      if (config.compute.has(name)) {\n        const computeLambda = config.compute.get(name)!;\n        // Inline it via IIFE for the lambda, or direct call\n        const inlineCall = ctx.factory.createCallExpression(computeLambda, undefined, [\n          sourceIdent,\n        ]);\n        resultProperties.push(ctx.factory.createPropertyAssignment(name, inlineCall));\n        continue;\n      }\n\n      // Is it renamed?\n      let sourceName = name;\n      if (config.rename.has(name)) {\n        sourceName = config.rename.get(name)!;\n      }\n\n      // Find in source\n      if (fromPropNames.has(sourceName)) {\n        // Determine safe property access\n        const isIdentifierName = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(sourceName);\n        const propAccess = isIdentifierName\n          ? ctx.factory.createPropertyAccessExpression(sourceIdent, sourceName)\n          : ctx.factory.createElementAccessExpression(\n              sourceIdent,\n              ctx.factory.createStringLiteral(sourceName)\n            );\n\n        // TODO: Deep type compatibility check using ctx.isAssignableTo\n        // and recursive transform if needed.\n\n        // Write the assignment: { targetName: sourceIdent.sourceName }\n        const isTargetIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name);\n        const propName = isTargetIdentifier\n          ? ctx.factory.createIdentifier(name)\n          : ctx.factory.createStringLiteral(name);\n\n        resultProperties.push(ctx.factory.createPropertyAssignment(propName, propAccess));\n        continue;\n      }\n\n      // Missing mapping\n      ctx.reportError(\n        callExpr,\n        `Cannot map field '${name}': No matching field '${sourceName}' in source type and no constant/compute rule provided.`\n      );\n    }\n\n    const objLit = ctx.factory.createObjectLiteralExpression(resultProperties, true);\n\n    // If we needed a temp variable, wrap in an IIFE\n    if (needsTempVar && tempName) {\n      return ctx.factory.createCallExpression(\n        ctx.factory.createArrowFunction(\n          undefined,\n          undefined,\n          [],\n          undefined,\n          ctx.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n          ctx.factory.createBlock(\n            [\n              ctx.factory.createVariableStatement(\n                undefined,\n                ctx.factory.createVariableDeclarationList(\n                  [\n                    ctx.factory.createVariableDeclaration(\n                      tempName,\n                      undefined,\n                      undefined,\n                      sourceExpr\n                    ),\n                  ],\n                  ts.NodeFlags.Const\n                )\n              ),\n              ctx.factory.createReturnStatement(objLit),\n            ],\n            true\n          )\n        ),\n        undefined,\n        []\n      );\n    }\n\n    return objLit;\n  },\n});\n\nfunction isSimpleLiteral(expr: ts.Expression): boolean {\n  return (\n    ts.isStringLiteral(expr) ||\n    ts.isNumericLiteral(expr) ||\n    expr.kind === ts.SyntaxKind.TrueKeyword ||\n    expr.kind === ts.SyntaxKind.FalseKeyword ||\n    expr.kind === ts.SyntaxKind.NullKeyword\n  );\n}\n\nfunction parseConfig(ctx: MacroContext, configExpr?: ts.Expression) {\n  const config = {\n    rename: new Map<string, string>(),\n    compute: new Map<string, ts.Expression>(),\n    const: new Map<string, ts.Expression>(),\n  };\n\n  if (!configExpr || !ts.isObjectLiteralExpression(configExpr)) {\n    return config;\n  }\n\n  for (const prop of configExpr.properties) {\n    if (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name)) {\n      const key = prop.name.text;\n      if (key === \"rename\" || key === \"compute\" || key === \"const\") {\n        if (ts.isObjectLiteralExpression(prop.initializer)) {\n          for (const subProp of prop.initializer.properties) {\n            if (ts.isPropertyAssignment(subProp)) {\n              let targetKey = \"\";\n              if (ts.isIdentifier(subProp.name)) {\n                targetKey = subProp.name.text;\n              } else if (ts.isStringLiteral(subProp.name)) {\n                targetKey = subProp.name.text;\n              }\n\n              if (targetKey) {\n                if (key === \"rename\" && ts.isStringLiteral(subProp.initializer)) {\n                  config.rename.set(targetKey, subProp.initializer.text);\n                } else if (key === \"compute\") {\n                  config.compute.set(targetKey, subProp.initializer);\n                } else if (key === \"const\") {\n                  config.const.set(targetKey, subProp.initializer);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return config;\n}\n\nexport function register(): void {\n  globalRegistry.register(transformIntoMacro);\n}\n"],"mappings":"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","names":[]}