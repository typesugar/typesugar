/**
 * Typesugar Prelude System
 *
 * The prelude provides a set of commonly-used typeclasses and extensions
 * that are always available in "automatic" resolution mode without explicit imports.
 *
 * In automatic mode, when the transformer encounters:
 *   - `p1 === p2` it resolves to `Eq<Point>.equals(p1, p2)`
 *   - `p1.show()` it resolves to `Show<Point>.show(p1)`
 *
 * Without prelude, users would need:
 *   import { Eq, Show } from "@typesugar/std";
 *
 * The prelude makes these common typeclasses "just work" for better DX.
 *
 * @module
 */

import { config } from "./config.js";

/**
 * Default prelude typeclasses and their locations.
 */
export interface PreludeEntry {
  /** Typeclass name (e.g., "Eq") */
  name: string;
  /** Module to import from (e.g., "@typesugar/std") */
  module: string;
  /** Methods provided by this typeclass */
  methods: string[];
  /** Operators provided by this typeclass */
  operators?: string[];
}

/**
 * The default prelude configuration.
 * These typeclasses are always in scope in "automatic" resolution mode.
 */
export const DEFAULT_PRELUDE: PreludeEntry[] = [
  {
    name: "Eq",
    module: "@typesugar/std",
    methods: ["equals"],
    operators: ["===", "!=="],
  },
  {
    name: "Ord",
    module: "@typesugar/std",
    methods: [
      "compare",
      "lessThan",
      "greaterThan",
      "lessThanOrEqual",
      "greaterThanOrEqual",
    ],
    operators: ["<", ">", "<=", ">="],
  },
  {
    name: "Show",
    module: "@typesugar/std",
    methods: ["show"],
  },
  {
    name: "Clone",
    module: "@typesugar/std",
    methods: ["clone"],
  },
  {
    name: "Debug",
    module: "@typesugar/std",
    methods: ["debug"],
  },
  {
    name: "Hash",
    module: "@typesugar/std",
    methods: ["hash"],
  },
  {
    name: "Default",
    module: "@typesugar/std",
    methods: ["defaultValue"],
  },
  {
    name: "Semigroup",
    module: "@typesugar/std",
    methods: ["combine"],
    operators: ["<>"],
  },
  {
    name: "Monoid",
    module: "@typesugar/std",
    methods: ["empty"],
  },
];

/**
 * Get the list of prelude typeclasses from configuration.
 */
export function getPreludeTypeclasses(): string[] {
  return (
    config.get<string[]>("resolution.prelude") ??
    DEFAULT_PRELUDE.map((e) => e.name)
  );
}

/**
 * Get the full prelude entry for a typeclass.
 */
export function getPreludeEntry(
  typeclassName: string,
): PreludeEntry | undefined {
  return DEFAULT_PRELUDE.find((e) => e.name === typeclassName);
}

/**
 * Check if a method is provided by a prelude typeclass.
 */
export function isPreludeMethod(methodName: string): PreludeEntry | undefined {
  return DEFAULT_PRELUDE.find((e) => e.methods.includes(methodName));
}

/**
 * Check if an operator is provided by a prelude typeclass.
 */
export function isPreludeOperator(operator: string): PreludeEntry | undefined {
  return DEFAULT_PRELUDE.find((e) => e.operators?.includes(operator));
}

/**
 * Generate a virtual ambient declaration for the prelude.
 * This is used by the language service to provide IntelliSense for prelude methods.
 */
export function generatePreludeDeclaration(): string {
  const lines: string[] = [
    "/**",
    " * Typesugar Prelude - Virtual Ambient Declarations",
    " * ",
    " * These declarations make prelude typeclasses available for IntelliSense",
    " * without explicit imports in 'automatic' resolution mode.",
    " * ",
    " * @internal Generated by @typesugar/core",
    " */",
    "",
    "declare global {",
  ];

  for (const entry of DEFAULT_PRELUDE) {
    lines.push(`  // ${entry.name} typeclass from ${entry.module}`);

    // Add method declarations as interface augmentations
    // Note: These are hints for the language service, not actual runtime augmentations
    for (const method of entry.methods) {
      lines.push(
        `  // ${entry.name}.${method}() available via implicit resolution`,
      );
    }

    if (entry.operators) {
      for (const op of entry.operators) {
        lines.push(`  // Operator '${op}' resolves to ${entry.name}`);
      }
    }

    lines.push("");
  }

  lines.push("}");
  lines.push("");
  lines.push("export {};");

  return lines.join("\n");
}

/**
 * Map from method name to the typeclass that provides it.
 * Used for quick lookups during transformation.
 */
export const METHOD_TO_TYPECLASS: Map<string, string> = new Map(
  DEFAULT_PRELUDE.flatMap((entry) =>
    entry.methods.map((method) => [method, entry.name] as const),
  ),
);

/**
 * Map from operator to the typeclass that provides it.
 * Used for quick lookups during operator transformation.
 */
export const OPERATOR_TO_TYPECLASS: Map<string, string> = new Map(
  DEFAULT_PRELUDE.filter((entry) => entry.operators).flatMap((entry) =>
    entry.operators!.map((op) => [op, entry.name] as const),
  ),
);
