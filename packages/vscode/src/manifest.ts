/**
 * Macro Manifest — The contract between the macro system and the IDE.
 *
 * The manifest is a JSON file (typemacro.manifest.json) that describes all
 * registered macros in a project. It is generated by `typemacro build --manifest`
 * and consumed by this extension to drive syntax highlighting, completions,
 * CodeLens, and diagnostics without hardcoding macro names.
 *
 * When a user adds a custom macro and regenerates the manifest, the extension
 * picks it up via file watcher — no extension code changes needed.
 */

import * as vscode from "vscode";
import * as path from "path";

// ---------------------------------------------------------------------------
// Manifest Types
// ---------------------------------------------------------------------------

export interface MacroManifest {
  version: number;
  macros: {
    expression: Record<string, ExpressionMacroEntry>;
    decorator: Record<string, DecoratorMacroEntry>;
    taggedTemplate: Record<string, TaggedTemplateMacroEntry>;
    labeledBlock: Record<string, LabeledBlockMacroEntry>;
    type: Record<string, TypeMacroEntry>;
    extensionMethods: Record<string, ExtensionMethodEntry>;
  };
}

export interface ExpressionMacroEntry {
  module: string;
  description?: string;
}

export interface DecoratorMacroEntry {
  module: string;
  description?: string;
  /** Known argument values (e.g., derive macro names) */
  args?: string[];
}

export interface TaggedTemplateMacroEntry {
  module: string;
  description?: string;
  /** Embedded language for template body highlighting */
  contentType?: string;
}

export interface LabeledBlockMacroEntry {
  module: string;
  description?: string;
  /** Continuation labels (e.g., ["yield", "pure"]) */
  continuations?: string[];
}

export interface TypeMacroEntry {
  module: string;
  description?: string;
}

export interface ExtensionMethodEntry {
  typeclass: string;
  description?: string;
  returnType?: string;
}

// ---------------------------------------------------------------------------
// Default Manifest (built-in macros, used when no manifest file exists)
// ---------------------------------------------------------------------------

export function createDefaultManifest(): MacroManifest {
  return {
    version: 1,
    macros: {
      expression: {
        comptime: {
          module: "typemacro",
          description: "Compile-time evaluation",
        },
        ops: {
          module: "typemacro",
          description: "Operator overloading expressions",
        },
        pipe: { module: "typemacro", description: "Function pipeline" },
        compose: { module: "typemacro", description: "Function composition" },
        summon: {
          module: "typemacro",
          description: "Typeclass instance lookup",
        },
        extend: {
          module: "typemacro",
          description: "Extension method wrapper",
        },
        typeInfo: {
          module: "typemacro",
          description: "Compile-time type reflection",
        },
        fieldNames: {
          module: "typemacro",
          description: "Compile-time field name extraction",
        },
        validator: {
          module: "typemacro",
          description: "Compile-time validator generation",
        },
        Do: {
          module: "typemacro",
          description: "Do-comprehension (generator style)",
        },
        forYield: {
          module: "typemacro",
          description: "For-yield comprehension",
        },
        asyncDo: { module: "typemacro", description: "Async do-comprehension" },
        specialize: {
          module: "typemacro",
          description: "Zero-cost typeclass specialization",
        },
      },
      decorator: {
        derive: {
          module: "typemacro",
          description: "Auto-derive implementations",
          args: [
            "Eq",
            "Ord",
            "Clone",
            "Debug",
            "Hash",
            "Default",
            "Json",
            "Builder",
          ],
        },
        operators: {
          module: "typemacro",
          description: "Operator overloading for classes",
        },
        reflect: {
          module: "typemacro",
          description: "Runtime reflection metadata",
        },
        typeclass: { module: "typemacro", description: "Define a typeclass" },
        instance: {
          module: "typemacro",
          description: "Define a typeclass instance",
        },
        deriving: {
          module: "typemacro",
          description: "Auto-derive typeclass instances",
        },
        inline: {
          module: "typemacro",
          description: "Inline function at call sites",
        },
      },
      taggedTemplate: {
        sql: {
          module: "typemacro",
          description: "SQL template with validation",
          contentType: "sql",
        },
        regex: {
          module: "typemacro",
          description: "Regex with compile-time validation",
          contentType: "regex",
        },
        html: {
          module: "typemacro",
          description: "HTML template",
          contentType: "html",
        },
        fmt: {
          module: "typemacro",
          description: "Format string",
          contentType: "format-string",
        },
        json: {
          module: "typemacro",
          description: "JSON template",
          contentType: "json",
        },
        raw: { module: "typemacro", description: "Raw string (no escaping)" },
        units: {
          module: "typemacro",
          description: "Dimensional analysis",
          contentType: "units",
        },
      },
      labeledBlock: {
        let: {
          module: "typemacro",
          description: "Monadic do-notation comprehension",
          continuations: ["yield", "pure"],
        },
      },
      type: {
        Add: { module: "typemacro", description: "Type-level addition" },
        Sub: { module: "typemacro", description: "Type-level subtraction" },
        Mul: { module: "typemacro", description: "Type-level multiplication" },
        Div: { module: "typemacro", description: "Type-level division" },
        Mod: { module: "typemacro", description: "Type-level modulo" },
      },
      extensionMethods: {
        show: {
          typeclass: "Show",
          description: "Convert to string representation",
          returnType: "string",
        },
        eq: {
          typeclass: "Eq",
          description: "Check equality",
          returnType: "boolean",
        },
        neq: {
          typeclass: "Eq",
          description: "Check inequality",
          returnType: "boolean",
        },
        compare: {
          typeclass: "Ord",
          description: "Compare ordering",
          returnType: "-1 | 0 | 1",
        },
        hash: {
          typeclass: "Hash",
          description: "Compute hash code",
          returnType: "number",
        },
        combine: {
          typeclass: "Semigroup",
          description: "Combine values",
          returnType: "self",
        },
        empty: {
          typeclass: "Monoid",
          description: "Identity element",
          returnType: "self",
        },
        map: {
          typeclass: "Functor",
          description: "Map over contained values",
          returnType: "self",
        },
      },
    },
  };
}

// ---------------------------------------------------------------------------
// Manifest Loader
// ---------------------------------------------------------------------------

export class ManifestLoader {
  private manifest: MacroManifest;
  private watcher: vscode.FileSystemWatcher | undefined;
  private readonly onDidChangeEmitter =
    new vscode.EventEmitter<MacroManifest>();

  /** Fires when the manifest changes (file updated or created) */
  readonly onDidChange = this.onDidChangeEmitter.event;

  constructor() {
    this.manifest = createDefaultManifest();
  }

  /** Current manifest snapshot */
  get current(): MacroManifest {
    return this.manifest;
  }

  /** Quick lookup helpers derived from the manifest */
  get expressionMacroNames(): Set<string> {
    return new Set(Object.keys(this.manifest.macros.expression));
  }

  get decoratorMacroNames(): Set<string> {
    return new Set(Object.keys(this.manifest.macros.decorator));
  }

  get taggedTemplateMacroNames(): Set<string> {
    return new Set(Object.keys(this.manifest.macros.taggedTemplate));
  }

  get labeledBlockLabels(): Set<string> {
    const labels = new Set<string>();
    for (const [label, entry] of Object.entries(
      this.manifest.macros.labeledBlock,
    )) {
      labels.add(label);
      for (const cont of entry.continuations ?? []) {
        labels.add(cont);
      }
    }
    return labels;
  }

  get extensionMethodNames(): Set<string> {
    return new Set(Object.keys(this.manifest.macros.extensionMethods));
  }

  /** All derive argument names across all decorator macros */
  get deriveArgNames(): Set<string> {
    const names = new Set<string>();
    for (const entry of Object.values(this.manifest.macros.decorator)) {
      for (const arg of entry.args ?? []) {
        names.add(arg);
      }
    }
    return names;
  }

  /**
   * Initialize: load manifest from disk and start watching for changes.
   */
  async initialize(workspaceFolder: vscode.WorkspaceFolder): Promise<void> {
    const config = vscode.workspace.getConfiguration("typemacro");
    const manifestRelPath = config.get<string>(
      "manifestPath",
      "typemacro.manifest.json",
    );
    const pattern = new vscode.RelativePattern(
      workspaceFolder,
      manifestRelPath,
    );

    // Try to load existing manifest
    await this.loadFromDisk(workspaceFolder, manifestRelPath);

    // Watch for changes
    this.watcher = vscode.workspace.createFileSystemWatcher(pattern);
    this.watcher.onDidChange(() =>
      this.loadFromDisk(workspaceFolder, manifestRelPath),
    );
    this.watcher.onDidCreate(() =>
      this.loadFromDisk(workspaceFolder, manifestRelPath),
    );
    this.watcher.onDidDelete(() => {
      this.manifest = createDefaultManifest();
      this.onDidChangeEmitter.fire(this.manifest);
    });
  }

  private async loadFromDisk(
    workspaceFolder: vscode.WorkspaceFolder,
    relativePath: string,
  ): Promise<void> {
    const uri = vscode.Uri.joinPath(workspaceFolder.uri, relativePath);
    try {
      const content = await vscode.workspace.fs.readFile(uri);
      const parsed = JSON.parse(
        Buffer.from(content).toString("utf-8"),
      ) as MacroManifest;

      if (parsed.version !== 1) {
        vscode.window.showWarningMessage(
          `typemacro: Unsupported manifest version ${parsed.version}. Expected 1.`,
        );
        return;
      }

      // Merge with defaults so built-in macros are always present
      this.manifest = mergeManifests(createDefaultManifest(), parsed);
      this.onDidChangeEmitter.fire(this.manifest);
    } catch {
      // No manifest file — use defaults (this is fine for projects that
      // only use built-in macros)
    }
  }

  dispose(): void {
    this.watcher?.dispose();
    this.onDidChangeEmitter.dispose();
  }
}

/**
 * Merge a base manifest with an overlay. Overlay entries win on conflict.
 */
function mergeManifests(
  base: MacroManifest,
  overlay: MacroManifest,
): MacroManifest {
  return {
    version: overlay.version,
    macros: {
      expression: { ...base.macros.expression, ...overlay.macros.expression },
      decorator: { ...base.macros.decorator, ...overlay.macros.decorator },
      taggedTemplate: {
        ...base.macros.taggedTemplate,
        ...overlay.macros.taggedTemplate,
      },
      labeledBlock: {
        ...base.macros.labeledBlock,
        ...overlay.macros.labeledBlock,
      },
      type: { ...base.macros.type, ...overlay.macros.type },
      extensionMethods: {
        ...base.macros.extensionMethods,
        ...overlay.macros.extensionMethods,
      },
    },
  };
}

// ---------------------------------------------------------------------------
// Manifest Generator (for use by the CLI)
// ---------------------------------------------------------------------------

/**
 * Generate a manifest JSON string from the global macro registry.
 * This is called by `typemacro build --manifest` in the CLI.
 *
 * Exported separately so the CLI can import it without pulling in vscode.
 */
export function generateManifestFromRegistry(
  registry: {
    getAll(): Array<{
      kind: string;
      name: string;
      module?: string;
      description?: string;
      label?: string;
      continuationLabels?: string[];
    }>;
  },
  extensionMethods?: Record<
    string,
    { typeclass: string; description?: string; returnType?: string }
  >,
): MacroManifest {
  const manifest: MacroManifest = {
    version: 1,
    macros: {
      expression: {},
      decorator: {},
      taggedTemplate: {},
      labeledBlock: {},
      type: {},
      extensionMethods: extensionMethods ?? {},
    },
  };

  for (const macro of registry.getAll()) {
    const entry = {
      module: macro.module ?? "typemacro",
      description: macro.description,
    };

    switch (macro.kind) {
      case "expression":
        manifest.macros.expression[macro.name] = entry;
        break;
      case "attribute":
        manifest.macros.decorator[macro.name] = entry;
        break;
      case "derive":
        // Derive macros go into the decorator.derive.args list
        if (!manifest.macros.decorator.derive) {
          manifest.macros.decorator.derive = {
            module: "typemacro",
            description: "Auto-derive implementations",
            args: [],
          };
        }
        manifest.macros.decorator.derive.args!.push(macro.name);
        break;
      case "tagged-template":
        manifest.macros.taggedTemplate[macro.name] = entry;
        break;
      case "labeled-block":
        manifest.macros.labeledBlock[macro.label ?? macro.name] = {
          ...entry,
          continuations: macro.continuationLabels,
        };
        break;
      case "type":
        manifest.macros.type[macro.name] = entry;
        break;
    }
  }

  return manifest;
}
