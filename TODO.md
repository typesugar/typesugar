# ttfx — Project TODO

## Wins (what we do well)

### vs ts-macros (GoogleFeud/ts-macros)

| Area                       | ttfx                                                                                                 | ts-macros                                                    |
| -------------------------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| **Type checker access**    | Macros read the type checker -- `typeInfo<T>()`, `validator<T>()`, derive macros inspect fields      | No type checker access; token-level expansion only           |
| **Derive macros**          | `@derive(Eq, Ord, Clone, Debug, Hash, Default, Json, Builder)` -- 8 built-in derives                 | Nothing comparable; users manually write repetitive code     |
| **Reflection**             | `typeInfo<T>()`, `fieldNames<T>()`, `validator<T>()`, `@reflect`                                     | No reflection capabilities                                   |
| **Tagged templates**       | First-class macro category with validation hooks (`sql`, `regex`, `html`, `units`, `fmt`, `json`)    | Tagged templates shoehorned through expression macros        |
| **Typeclasses**            | Full Scala 3-style system: `@typeclass`, `@instance`, `@deriving`, `summon()`, implicit extensions   | Nothing comparable                                           |
| **Operator overloading**   | `@operators` + `ops()` with compile-time rewriting                                                   | Not supported                                                |
| **Safety**                 | Sandboxed `vm` with timeout, no fs/net/process access                                                | `$raw` and `$comptime` run unsandboxed with full Node access |
| **Diagnostics**            | Errors flow through the TS diagnostic pipeline; failed expansions emit runtime throws                | Console-based error reporting                                |
| **Macro categories**       | 4 distinct categories (expression, tagged template, derive, attribute) with typed definition helpers | Single macro type with `$` prefix convention                 |
| **Zero-cost abstractions** | `specialize` macro inlines typeclass dictionaries at compile time — no runtime overhead for HKT/FP   | No equivalent; all abstractions have runtime cost            |
| **Test suite**             | 515 tests across 13 test files, all passing                                                          | Tests exist but less comprehensive                           |

### vs ts-macro (Volar-based)

ts-macro is a completely different tool -- it extends TypeScript's language service (like Vue's Volar) rather than doing compile-time code transformation. Not a direct competitor, but worth noting:

- **ttfx** transforms code at build time (source-to-source)
- **ts-macro** extends IDE type checking (no code generation)

### vs Babel macros

- Babel macros have no TypeScript type awareness
- Babel macros require the Babel toolchain (not tsc)
- ttfx works within the TypeScript compiler itself

### Unique features (no competitor has these)

1. **Zero-cost abstractions** -- `specialize` macro eliminates typeclass dictionary passing at compile time; HKT/FP code compiles to direct calls with no runtime overhead
2. **Dimensional analysis** -- `units` tagged template with compile-time unit checking
3. **Do-comprehension macros** -- Scala-style `Do()`, `forYield()`, `asyncDo()`, `For()`, `comprehend()`, and labeled-block `let:/yield:` syntax
4. **Typeclass system** with auto-derivation, `summon()`, and implicit extension methods (`point.show()` without wrappers)
5. **Compile-time validators** generated from types (`validator<User>()`)
6. **Advanced type system extensions** -- HKT, existential types, refinement types, type-level arithmetic, opaque type modules, phantom state machines, effect system annotations

---

## TODO -- Improvements

### High Priority

- [x] **IDE Plugin / Language Service** -- TS language service plugin at `ttfx/language-service`. Suppresses false-positive diagnostics from macro decorators and implicit extension methods, provides completions inside `@derive()` and for extension methods on member access, and shows macro/extension info on hover. Configure via `"plugins": [{ "name": "ttfx/language-service" }]` in tsconfig.json.
- [x] **VSCode Extension** -- Full IDE extension at `packages/vscode/` (`@ttfx/vscode`). Manifest-driven architecture: all macro names come from `ttfx.manifest.json` (generated by `ttfx build --manifest`), so adding new macros automatically gets IDE support. Features:
  - **Syntax highlighting**: TextMate injection grammar for structural syntax (`let:`/`yield:` comprehensions, `<<` bind operator, macro invocations). Semantic tokens provider for manifest-driven highlighting of expression macros, decorators, tagged templates, extension methods, derive arguments, and bind variables.
  - **Embedded language support**: SQL/HTML/regex/units highlighting inside tagged template macros via `contentType` field in manifest.
  - **CodeLens**: Clickable expansion previews above macro invocations showing what the macro expands to.
  - **Inlay hints**: Bind variable types in comprehensions (`user: User`), comptime results (`= 120`).
  - **Code actions**: "Expand macro" (replace with expansion), "Wrap in comptime", "Add @derive" (quick-pick).
  - **Diagnostics bridge**: Runs transformer in background on save, surfaces macro-specific errors with rich related info.
  - **Color theming**: Semantic token color defaults (macros bold purple, extension methods italic teal, comptime italic, bind variables bold).
  - **Status bar**: Shows macro count, click to refresh manifest.
  - **Manifest CLI**: `ttfx build --manifest` serializes the global registry to `ttfx.manifest.json`. Extension watches the file and hot-reloads.
- [x] **Implicit extension methods** -- Typeclass extension methods work without wrappers: `point.show()` instead of `extend(point).show()`. The transformer detects method calls that don't exist on the type, checks the extension registry, and rewrites to `TC.summon<T>("T").method(...)`. The language service suppresses false "Property does not exist" errors, provides completions, and shows hover info.
- [x] **Pre-processor mode** -- unplugin-based integration works with Vite, Webpack, esbuild, Rollup, and Rspack without patching tsc. Import from `ttfx/vite`, `ttfx/webpack`, etc.
- [x] **Error messages in comptime** -- Errors now include source location, a snippet of the failing code, and hints for common problems (timeout, sandbox restrictions, null access).
- [x] **Documentation site** -- Created docs/ directory with microsite skeleton: getting-started.md, macro-types.md, writing-macros.md, architecture.md, faq.md. Full docs site deployment still pending.

### Medium Priority

- [x] **Consolidate src/ and packages/ directories** — Code duplication between legacy `src/` and `packages/` addressed:
  - **packages/ now builds cleanly**: All `@ttfx/*` packages build successfully with full DTS generation
  - **Fixed in packages/cats**: Export collisions resolved via namespace exports, DTS build errors fixed by adding explicit type parameters to higher-order typeclass functions, HKT re-exports corrected, IO/Resource/Console type mismatches resolved
  - **Fixed in packages/type-system**: Missing closing brace, implicit any parameters, unknown type assertions
  - **Fixed in packages/transformer**: Added `./cli` export to package.json
  - **Fixed in src/**: `cloneNode` errors in `context.ts`/`quote.ts`, `multiLine` property in `pipeline.ts`, export collisions in `src/use-cases/cats/data/index.ts`, implicit any in `test-utils`, control flow narrowing in `cfg.ts`
  - **Remaining in src/**: Legacy example files (`validated.ts`, `console-app.ts`) have type issues but are not blocking package builds
  - **Recommendation**: Keep `src/` for development/examples but don't ship it; `packages/` is the canonical source

- [x] **Stub implementations to complete** — Addressed:
  - `packages/cats/src/typeclasses/traverse.ts`: Added `flatTraverseK` that properly uses `MonoidK<F>` for flattening; deprecated old `flatTraverse`
  - `packages/cats/src/typeclasses/alternative.ts`: Added safe bounded alternatives: `manyBounded`, `someBounded`, `replicateA` with explicit `maxTimes` parameter
  - Remaining: `packages/comptime/src/index.ts` (limited statement evaluation), various `// TODO` comments for edge cases

- [x] **Test coverage gaps** — Added comprehensive tests:
  - `packages/cats/src/io/io.test.ts`: 54 tests covering IO monad constructors, functor/monad laws, error handling, resource management, traversals, control flow, retry, sync running, do-notation, fluent API, stack safety
  - `packages/cats/src/data/data.test.ts`: 39 tests covering Option, Either, List (constructors, guards, functor, monad, filter, folds, utilities, stack safety)
  - Remaining gaps: `packages/comptime/` edge cases, `packages/cats/src/effect/` Effect types, `packages/vscode/` extension tests, unplugin adapter integration tests, `packages/react/` and `packages/testing/` tests

- [x] **Modular macro registration** — Refactored:
  - Split into "core" macros (always loaded: comptime, derive, operators, reflect) and "module" macros (lazy-loaded)
  - Replaced `src/use-cases/` with proper supported modules in `packages/` (e.g., `@ttfx/testing`, `@ttfx/sql`, `@ttfx/react`)
  - Each module package self-registers when imported
  - **References**: `src/macros/index.ts`, `src/core/registry.ts`, `src/transforms/macro-transformer.ts`

- [x] **Import-scoped macro activation** -- Macros are now only activated when the user imports the placeholder from the declaring module (e.g., `import { comptime } from "ttfx"`). The transformer uses `getAliasedSymbol` to trace identifiers through barrel re-exports, renamed imports, and namespace imports back to their origin module. Macros declare their source via the `module` field on `MacroDefinitionBase`. Macros without `module` still work via name-based lookup (backward compatibility). All built-in macros now declare `module: "ttfx"`.
- [ ] **Caching** -- Expensive `comptime()` evaluations are re-run on every compilation. Add a persistent cache (hash input -> output) to speed up incremental builds.
- [ ] **Source maps for expanded code** -- Source maps currently point to the original macro invocation, but expanded multi-statement code (derive, reflect) could have better mapping. The unplugin integration has a TODO for proper source map generation.
- [ ] **Macro composition** -- Allow macros to call other macros cleanly. Currently possible but not ergonomic.
- [x] **Watch mode integration** -- `npx ttfx watch` is implemented in the CLI.
- [x] **CLI tool** -- `npx ttfx build/watch/check` commands are implemented. See `src/cli/index.ts`.
- [ ] **Custom derive macros** -- Users can define expression/attribute/tagged-template macros, but defining custom derive macros requires understanding internal `DeriveTypeInfo` structures. Need a simpler API.

- [ ] **Specialization Ergonomics** -- Three levels of compile-time specialization for typeclass-based generic programming:

  **Level 1: Auto-Specialize Known Instances** (implement now)

  When the transformer sees a function call where an argument is a reference to a **registered instance dictionary** (e.g., `optionMonad`, `arrayFunctor`), it automatically inlines the dictionary methods -- no `specialize()` wrapper needed.

  ```typescript
  // Today: manual, verbose
  const doubleOption = specialize(double, optionMonad);

  // With Level 1: just call with the known instance
  double(optionMonad, myOpt); // compiler sees optionMonad → inlines automatically
  ```

  Implementation: Add `tryAutoSpecialize` method to `src/transforms/macro-transformer.ts`. When visiting `CallExpression`, check if any argument is a reference to a registered instance. If so, resolve the function body and inline dictionary method calls.

  **Level 2: Scoped Specialization** (design for later)

  Eliminate dictionary arguments entirely within a scope. The compiler resolves the instance from context, like Scala's `given`/`using` or Haskell's implicit resolution.

  ```typescript
  @using(optionMonad)
  function processOptions() {
    const result = double(myOpt);  // no dictionary arg! resolved from scope
  }

  // Or: import-time scope
  import { optionMonad } from "@ttfx/fp" with { implicit: true };
  ```

  The transformer maintains a **scope stack** of active instances. Generic function calls auto-resolve their dictionary arguments from scope, then apply Level 1 auto-specialization.

  Key challenge: ambiguity resolution when multiple instances are in scope. Requires type-directed resolution -- match argument types to the instance that handles them.

  **Level 3: Multi-Clause / Pattern-Matched Functions** (design for later)

  Define functions with multiple clauses that dispatch on type or value at compile time, like Haskell/Erlang pattern matching.

  ```typescript
  @multimethod
  function factorial(n: 0): 1 { return 1; }
  function factorial(n: number): number { return n * factorial(n - 1); }
  // Generates: (n) => n === 0 ? 1 : n * factorial(n - 1)

  @multimethod
  function show(x: number): string { return x.toString(); }
  function show(x: string): string { return `"${x}"`; }
  // Generates: typeof x === "number" ? x.toString() : `"${x}"`
  ```

  Multi-clause functions subsume type specialization: a typeclass instance is essentially a multi-clause function dispatched on the type constructor.

  Implementation: `@multimethod` attribute macro collects consecutive same-named declarations, generates a single function with compile-time dispatch logic. Integrates with `comptime()` for constant folding when arguments are known literals.

  **Progression**: Level 1 → 2 → 3. Each builds on the previous. Level 1 makes specialization automatic at call sites, Level 2 makes dictionary arguments implicit, Level 3 generalizes to arbitrary compile-time dispatch.

- [ ] **`Eval` monad for fp library** -- Add a trampolined lazy evaluation monad (`Eval<A>`) to `@ttfx/fp`. **Not needed for List operations** (those were converted to iterative while loops), but valuable for:
  - **Lazy short-circuiting `foldRight`** — The current `foldRight` is strict (processes all elements). An `Eval`-based version can stop early, e.g., `foldRight(hugeList, Eval.now(true), (a, eb) => a ? eb : Eval.now(false))` stops at first `false`.
  - **Tree data structures** — Binary trees, rose trees, etc. can't easily be iterated; `Eval.defer` makes recursion stack-safe without rewriting.
  - **Memoized lazy values** — `Eval.later(() => expensive())` computes once on first access.
  - **IO monad internals** — Stack-safe effect composition via trampolining.
  - **Mutual recursion** — When A calls B calls A, accumulators don't help; `Eval.defer` does.

  Implementation (~100-150 lines):

  ```typescript
  type Eval<A> = Now<A> | Later<A> | Always<A> | Defer<A> | FlatMap<A>;
  // .value getter runs a trampoline loop
  ```

  Trampolines work well in JS — heap-allocate continuations instead of stack frames, driver loop evaluates iteratively.

### Low Priority / Nice to Have

- [ ] **WASM sandbox** -- Alternative to Node's `vm` for additional isolation in comptime evaluation.
- [ ] **Conditional compilation** -- `#[cfg(...)]` style conditional code inclusion based on environment variables or build config.
- [ ] **Macro hygiene improvements** -- Generated identifiers use `__ttfx_` prefix, but there's no formal hygiene system preventing name collisions in complex expansions.
- [x] **Performance benchmarks** -- Benchmark suite in `tests/benchmark.test.ts` covering AST evaluator, registry lookups, expression parsing, value conversion, and comptime checks. Run with `npx vitest run tests/benchmark.test.ts`.
- [ ] **ESLint plugin** -- Lint rules for common macro mistakes (e.g., side effects in comptime, missing derive fields).
- [ ] **Playground** -- ts-macros has an online playground. We should have one too.
- [x] **CI/CD** -- GitHub Actions CI configured with test matrix across Node 18/20/22 and TypeScript 5.4-5.8. Includes lint, typecheck, and publish dry-run jobs. See `.github/workflows/ci.yml`.
- [ ] **npm publish** -- Package is not yet published. CI is set up; need to add npm publish workflow and changelog generation.
- [ ] **GitHub repo** -- Create the public repo, set up issues, and branch protection.

### Performance Optimizations (completed)

Systematic profiling and optimization pass across the core macro pipeline:

| Area                  | Optimization                                                                  | Impact                                                              |
| --------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **AST evaluator**     | SyntaxKind-based switch dispatch instead of chained `ts.isXxx()` guards       | 1.3-2.5x faster evaluation                                          |
| **AST evaluator**     | Pre-allocated sentinel objects for `true`/`false`/`null`/`undefined`          | Eliminates GC pressure on hot path                                  |
| **AST evaluator**     | Array pre-allocation with indexed assignment instead of `.map()` + `.find()`  | 11x faster array literal evaluation                                 |
| **AST evaluator**     | Reuse boolean sentinels in comparison results                                 | Fewer allocations per binary op                                     |
| **Transformer**       | Bound visitor function created once in constructor (`boundVisit`)             | Eliminates closure allocation per `visitNode`/`visitEachChild` call |
| **Transformer**       | SyntaxKind-based dispatch in `tryTransform()`                                 | Fast rejection of non-macro nodes                                   |
| **Transformer**       | Module specifier resolution cache                                             | Avoids repeated regex/string matching per file                      |
| **Transformer**       | Avoid `Array.from()` on `NodeArray` in `visitStatementContainer`              | Zero-copy iteration                                                 |
| **Extension methods** | Direct AST construction instead of string concatenation + `parseExpression()` | 3-4x faster rewriting                                               |
| **Comptime VM**       | Shared sandbox + `vm.Context` across all evaluations                          | Eliminates per-call context creation                                |
| **Comptime VM**       | Pre-compiled regex patterns for JS cleanup                                    | Avoids regex compilation per call                                   |
| **Comptime VM**       | Shared `TranspileOptions` object                                              | Eliminates per-call options allocation                              |
| **Shared**            | Lazy shared `ts.Printer` on context and transformer                           | Avoids creating printer per `nodeToString` call                     |

Microbenchmark results (isolated run, single fork):

| Benchmark                   | Before       | After        | Speedup   |
| --------------------------- | ------------ | ------------ | --------- |
| numeric literal eval        | 3.6M ops/sec | 6.5M ops/sec | **1.8x**  |
| binary arithmetic eval      | 233K ops/sec | 589K ops/sec | **2.5x**  |
| array literal (20 elements) | 24K ops/sec  | 272K ops/sec | **11.3x** |
| parse complex expression    | 28K ops/sec  | 106K ops/sec | **3.8x**  |
| primitive value conversion  | 3.0M ops/sec | 6.6M ops/sec | **2.2x**  |
| nested object conversion    | 194K ops/sec | 354K ops/sec | **1.8x**  |
| parse simple expression     | 77K ops/sec  | 147K ops/sec | **1.9x**  |

### End-to-end performance (real pipeline, `benchmark-e2e.test.ts`)

Full pipeline timing breakdown (program creation is the dominant cost):

| Scenario                  | Program creation | Transform + print | Transform only (program reused) |
| ------------------------- | ---------------- | ----------------- | ------------------------------- |
| 50-line file, no macros   | ~294ms (80%)     | ~71ms (20%)       | **1.1ms**                       |
| 200-line file, no macros  | ~231ms (76%)     | ~71ms (24%)       | **4.6ms**                       |
| 1000-line file, no macros | ~230ms (72%)     | ~91ms (28%)       | **22.1ms**                      |
| 50 macro calls            | —                | —                 | **0.9ms**                       |
| 100 macro calls           | —                | —                 | **1.7ms**                       |
| 1000 lines + 100 macros   | ~271ms (72%)     | ~106ms (28%)      | **14.7ms**                      |

Key findings:

- **`ts.createProgram()` dominates** at 230-300ms (70-80% of total) — outside our control
- **Per-macro marginal cost: ~19μs** — essentially free
- **Visitor overhead: ~23-41μs per line** — scales linearly (17.7x for 20x more lines)
- **In a real build** (program created once), the per-file cost is just 1-23ms
- The microbenchmark optimizations (1.8x-11x) improve operations that contribute <0.1% of end-to-end time

### Remaining Performance Opportunities

- [ ] **Comptime expression caching** -- Hash comptime input → cache output across incremental builds (tracked in Medium Priority)
- [ ] **Incremental transformer** -- Skip files with no macro imports entirely (fast path for non-macro files)
- [ ] **Batch transpileModule** -- Collect multiple comptime expressions and transpile in a single `transpileModule` call
- [ ] **Source map optimization** -- Expanded multi-statement code (derive, reflect) could use more efficient source map generation
- [ ] **Benchmark real comptime/derive/reflect macros** -- Current e2e benchmarks use a trivial passthrough macro; need to measure the actual `transpileModule` + `vm.runInContext` path and derive expansion on classes with many fields

### Robustness Issues Identified (all resolved)

- [x] **Type checker call safety** -- All `getTypeAtLocation()`, `getPropertiesOfType()`, `typeToString()` calls wrapped in try-catch with graceful fallbacks.
- [x] **Extension method getText() fragility** -- Added `safeGetText()` helper that falls back to `printer.printNode()` for synthetic nodes. Audited all macros.
- [x] **Decorator parsing silent failures** -- Enhanced `parseDecorator()` to handle property access patterns. Unrecognized decorators pass through correctly.
- [x] **Import cleanup for namespace imports** -- Verified existing conservative logic is correct: namespace imports preserved unless the namespace itself resolved to a macro.
- [x] **Test timeout flakiness** -- Increased default timeouts and relaxed environment-dependent benchmark thresholds.

### Known Limitations (documented, not bugs)

- Decorators only work on classes (TypeScript limitation) -- interfaces/type aliases use expression macros instead
- `comptime()` sandbox has no I/O (by design -- safety feature)
- 5-second timeout on compile-time evaluation (configurable but not yet exposed)
- ts-patch is still the most reliable path for tsc users; unplugin integration is the alternative for bundler users

---

## Implemented: Advanced Type System Extensions

All in `packages/type-system/`. Tests in `tests/type-system.test.ts` (80 tests).

### Higher-Kinded Types (HKT) -- `hkt.ts`

- `$<F, A>` / `Kind<F, A>` type application via indexed-access encoding (zero-cost, no registry)
- Built-in type-level functions: `ArrayF`, `PromiseF`, `SetF`, `ReadonlyArrayF`, `MapF<K>`
- Natively understood by TypeScript -- no `as unknown as` casts, no module augmentation
- Typeclasses (`Functor`, `Monad`, etc.) moved to `@ttfx/fp` package

### Specialization / Zero-Cost Abstractions -- `specialize.ts`

- `specialize(fn, dict)` expression macro eliminates typeclass dictionary passing at compile time
- `specialize$(dict, expr)` inline specialization for expressions
- Instance method registry maps dictionary names to their concrete implementations
- Method inlining: `F.map(fa, f)` → `fa.map(f)` (Array) or `fa._tag === "Some" ? Some(f(fa.value)) : None` (Option)
- Dictionary parameter elimination from function signatures
- Fallback to partial application when dictionary isn't known at compile time
- Built-in registrations for Array, Promise, Option, Either instances

### Cats-style FP Library -- `use-cases/cats/`

- Unified HKT system: all typeclasses use `Kind<F, A>` (single source of truth)
- Full typeclass hierarchy: `Functor`, `Apply`, `Applicative`, `FlatMap`, `Monad`, `Foldable`, `Traverse`
- Error handling: `ApplicativeError`, `MonadError`
- Algebraic: `Semigroup`, `Monoid`, `SemigroupK`, `MonoidK`, `Alternative`
- Structural: `Semigroupal`, `Eq`, `Ord`, `Show`
- Concrete instances for `Option`, `Either`, `Array`, `Promise` (all registered for specialization)
- 61 tests covering laws, derived operations, and generic programming

### Existential Types -- `existential.ts`

- CPS-encoded existentials: `packExists(witness)` / `useExists(packed, callback)`
- Heterogeneous collections via `ExistsList<W>`
- Pre-built patterns: `Showable`, `Comparable`, `Serializable`
- `@existential` attribute macro generates pack/use helpers for interfaces

### Refinement Types -- `refined.ts`

- `Refined<Base, Brand>` branded types with predicate validation
- `refinement()` creates validators with `refine/is/from/safe` methods
- `composeRefinements()` for combining predicates
- 15+ built-in refinements: `Positive`, `Byte`, `Port`, `Email`, `Uuid`, `NonEmpty`, etc.
- `refine` expression macro for compile-time literal validation

### GADTs -- REMOVED

**Status**: Removed from the codebase.

The previous `gadt.ts` implementation was dropped because:

1. It did not provide type-parameter narrowing on match (the core feature of GADTs)
2. Its functionality for tagged unions was inferior to native TypeScript discriminated unions
3. The `@ttfx/fp` `match` macro already handles discriminated union matching better

**Future**: A proper GADT implementation with type-parameter narrowing (using `ctx.typeChecker` integration) is tracked as a future project. See PHILOSOPHY.md for the design principles that led to this decision.

### Type-Level Arithmetic -- `type-arithmetic.ts`

- **TypeMacro infrastructure** wired into the transformer (new macro kind!)
- 19 type macros: `Add`, `Sub`, `Mul`, `Div`, `Mod`, `Pow`, `Negate`, `Abs`, `Max`, `Min`
- Comparisons: `Lt`, `Lte`, `Gt`, `Gte`, `NumEq`
- Utilities: `Increment`, `Decrement`, `IsEven`, `IsOdd`
- All computed at compile time, emitting literal number/boolean types

### Opaque Type Modules -- `opaque.ts`

- ML-style abstract types: `opaqueModule<Repr>(brand, validate)(ops)`
- Smart constructors with validation, `tryCreate`, `isValid`
- Module-scoped operations that see the representation
- Pre-built modules: `PositiveInt`, `NonEmptyString`, `EmailAddress`, `SafeUrl`

### Phantom Type State Machines -- `phantom.ts`

- `createStateMachine()` with phantom type state tracking
- Type-safe builder pattern via `createBuilder()`
- Session/protocol types: `Send<T, Next>`, `Recv<T, Next>`, `Dual<P>`
- `@phantom` attribute macro generates state machine type definitions

### Effect System Annotations -- `effects.ts`

- `@pure` / `@effect("io", "async", ...)` decorators
- Compile-time effect checking: pure functions can't call effectful ones
- Effect propagation: missing effect declarations are caught
- Type-level effect tracking: `Effectful<Effects, T>`, `Pure<T>`, `IO<T>`, `Async<T>`

---

## Implemented: Labeled Block Comprehensions

Tests in `tests/comprehensions.test.ts` (51 tests).

### Labeled Block Macro Infrastructure

- New macro kind: `"labeled-block"` — matches labeled statements (`label: { ... }`)
- `LabeledBlockMacro` interface with `label`, `continuationLabels`, and `expand()`
- Transformer scans statement containers for labeled-block pairs and consumes siblings
- `defineLabeledBlockMacro()` helper and `getLabeledBlock()` registry method

### `let:/yield:` Comprehension Syntax

Haskell/Scala-style do-notation using labeled statements:

```typescript
let: {
  user << fetchUser(id); // monadic bind (flatMap/then)
  name = user.name.toUpperCase(); // pure map (no effect unwrapping)
  _ << log(name); // bind, discard result
  posts << getPosts(user.id) || getCachedPosts(user.id); // bind with orElse fallback
  if (posts.length > 0) {
  } // guard/filter
}
yield: {
  ({ user, name, posts });
}
```

#### Statement types inside `let:` block

| Syntax                  | Name          | Transforms to                                      |
| ----------------------- | ------------- | -------------------------------------------------- |
| `name << expr`          | Monadic bind  | `.flatMap(name => ...)` or `.then(name => ...)`    |
| `_ << expr`             | Discard bind  | `.flatMap(_ => ...)` — runs effect, ignores result |
| `name = expr`           | Pure map      | `((name) => ...)(expr)` — no effect unwrapping     |
| `name << expr \|\| alt` | Bind + orElse | `expr.orElse(() => alt).flatMap(name => ...)`      |
| `name << expr ?? alt`   | Bind + orElse | Same as `\|\|` variant                             |
| `if (cond) {}`          | Guard/filter  | `cond ? ... : undefined`                           |

#### Other features

- `yield:` or `pure:` provides the return expression (both accepted)
- Without `yield:`, the last binding's effect is the result
- **Promise/thenable detection**: When the first bind expression is a Promise (has `.then()` but no `.flatMap()`), emits `.then()` instead of `.flatMap()` — Promises work out of the box
- Object literals in `yield:` need parentheses: `yield: { ({ a, b }) }` (same as arrow functions)

### `par:/yield:` Applicative Comprehension Syntax

Applicative (parallel/independent) comprehension — the counterpart to `let:` for cases where bindings don't depend on each other:

```typescript
par: {
  user << fetchUser(id);
  posts << fetchPosts(postId);
  config << loadConfig();
}
yield: {
  ({ user, posts, config });
}
```

#### How it differs from `let:`

| Feature                         | `let:` (monadic)              | `par:` (applicative)                   |
| ------------------------------- | ----------------------------- | -------------------------------------- |
| Bindings can depend on previous | Yes                           | No (enforced at compile time)          |
| Chaining method                 | `.flatMap()` / `.then()`      | `.map().ap()` / `Promise.all`          |
| Error behavior                  | Short-circuits on first error | Can accumulate all errors (Validation) |
| Execution                       | Sequential                    | Independent (parallel for Promises)    |
| Guards (`if`)                   | Supported                     | Not supported                          |
| orElse (`\|\|`)                 | Supported                     | Not supported                          |

#### Statement types inside `par:` block

| Syntax         | Name               | Transforms to                            |
| -------------- | ------------------ | ---------------------------------------- |
| `name << expr` | Independent effect | `.map(a => b => c => ...).ap(fb).ap(fc)` |
| `name = expr`  | Pure computation   | `((name) => ...)(expr)` — IIFE wrapper   |

#### Transformation strategies

- **Standard types**: `fa.map(a => b => c => yield).ap(fb).ap(fc)` — requires `.map()` and `.ap()`
- **Promises**: `Promise.all([fa, fb, fc]).then(([a, b, c]) => yield)` — true parallel execution
- **Single binding**: Falls back to `.map()` / `.then()` (same as `let:`)

#### Independence validation

The macro statically checks that no binding references a previous binding's name. If a dependency is detected, it reports a compile-time error suggesting `let:` instead.

#### Why applicative matters

Every monad is an applicative, so `par:` works with all the same types as `let:`. But applicative enables:

1. **Error accumulation** — `Validation<E, A>` is applicative but not monadic; `par:` collects all errors instead of stopping at the first
2. **Parallelism** — For Promises, `Promise.all` runs all effects concurrently instead of sequentially
3. **Optimization** — Even for monads, the runtime knows all effects upfront

### Future work — Comprehension Typeclass

The long-term vision is a `Comprehension` typeclass that maps types to their chaining methods, enabling the macro to work with any monadic type without hardcoded method names.

#### Comprehension typeclass design

```typescript
@typeclass
interface Comprehension<F> {
  /** Monadic bind — unwrap and chain */
  bind<A, B>(fa: Kind<F, A>, f: (a: A) => Kind<F, B>): Kind<F, B>;
  /** Pure map — transform the inner value */
  map<A, B>(fa: Kind<F, A>, f: (a: A) => B): Kind<F, B>;
  /** Lift a pure value into the effect */
  pure<A>(a: A): Kind<F, A>;
  /** Empty/zero value for guard short-circuiting */
  empty<A>(): Kind<F, A>;
  /** Recovery/fallback on failure */
  orElse<A>(fa: Kind<F, A>, alt: () => Kind<F, A>): Kind<F, A>;
}
```

With instances:

```typescript
@instance Comprehension<Option> {
  bind: (fa, f) => fa.flatMap(f),
  map: (fa, f) => fa.map(f),
  pure: (a) => some(a),
  empty: () => none(),
  orElse: (fa, alt) => fa.isSome ? fa : alt(),
}

@instance Comprehension<Promise> {
  bind: (fa, f) => fa.then(f),
  map: (fa, f) => fa.then(f),
  pure: (a) => Promise.resolve(a),
  empty: () => Promise.reject(new Error("guard failed")),
  orElse: (fa, alt) => fa.catch(() => alt()),
}

@instance Comprehension<Either<E>> {
  bind: (fa, f) => fa.flatMap(f),
  map: (fa, f) => fa.map(f),
  pure: (a) => right(a),
  empty: () => left(undefined),
  orElse: (fa, alt) => fa.isRight ? fa : alt(),
}
```

Then the macro resolves the instance at compile time and generates the correct method calls. `@deriving(Comprehension)` could auto-derive for types with standard `.flatMap()/.map()` signatures.

#### TODO items

- [ ] **Comprehension typeclass** — Define the typeclass and register instances for Option, Either, IO, Promise, Array, Effect
- [ ] **Typeclass-driven code generation** — Macro resolves Comprehension instance at compile time, uses registered method names instead of hardcoded `.flatMap()`/`.map()`
- [ ] **`@deriving(Comprehension)`** — Auto-derive for types with `.flatMap()` and `.map()` methods
- [ ] **Guard with proper empty** — Currently guards emit `undefined`; with the typeclass, emit `Comprehension.empty()` for the correct type
- [ ] **`orElse` with proper error mapping** — Support `<< expr || alt` with type-aware error recovery (`.catch()` for Promise, `.orElse()` for Option/Either, etc.)
- [ ] **`mapError` syntax** — Something like `x << expr |> mapError(...)` for transforming the error channel (needs pipeline operator or alternative syntax)
- [ ] **`where:` continuation label** — Local let-bindings that don't unwrap effects (like Haskell's `where` clause)
- [ ] **Nested comprehensions** — `let:` blocks inside `let:` blocks for nested monadic contexts
- [ ] **Pattern matching in bind** — Destructuring: `{ name, age } << fetchUser(id)` (TypeScript parses `({ name, age }) << expr` but it's awkward)
- [ ] **Import-scoped activation** — Currently name-based since labels aren't importable symbols; could use a sentinel import to gate the macro
- [ ] **Language service support** — Suppress "unused label" warnings, provide completions inside `let:` blocks, show inferred types for bindings
- [ ] **Integration with Effect ecosystem** — Map to `Effect.gen` / `Effect.flatMap` / `Effect.map` patterns

---

## Roadmap: Features from World-Class Macro Systems

Inspired by Rust proc_macro, Scala 3 macros, Zig comptime, Racket, Elixir, Nim, OCaml PPX, and Sweet.js. Organized into phases with dependencies mapped.

### Phase 1: Macro Authoring Ergonomics (Foundation)

Everything else gets easier once writing macros is pleasant. This phase has zero external dependencies and unblocks Phases 2-5.

#### 1.1 Quasiquoting / `quote` Template System

**Inspiration**: Rust `quote!`, Elixir `quote/unquote`, Lisp quasiquote

**Problem**: Every macro currently builds AST via `ts.factory.create*()` calls — verbose, error-prone, and hard to read. This is the #1 barrier to writing custom macros.

**Design**:

```typescript
import { quote, unquote } from "ttfx/quote";

// Instead of:
ctx.factory.createBinaryExpression(left, ts.SyntaxKind.PlusToken, right);

// Write:
quote`${left} + ${right}`;

// Multi-statement:
quote.statements`
  const ${name} = ${initializer};
  console.log(${name});
`;

// Type nodes:
quote.type`Array<${elementType}>`;
```

**Implementation**:

- [ ] **`quote` tagged template expression macro** — Parses template at compile time, replaces `${...}` splices with factory calls. Output is a `ts.Expression` or `ts.Statement[]`.
  - File: `src/macros/quote.ts`
  - The template string is parsed once at macro expansion time (not runtime)
  - Splices (`${expr}`) become `unquote` positions in the generated factory code
  - Literal portions become static factory calls (can be hoisted/cached)
- [ ] **Splice types** — Support different splice kinds:
  - `${expr}` — Splice a `ts.Expression` node
  - `${...stmts}` — Splice an array of `ts.Statement[]` (spread)
  - `${ident:name}` — Splice as identifier (string → `ts.Identifier`)
  - `${type:typeNode}` — Splice a `ts.TypeNode`
- [ ] **`quote.statements`** — Variant that returns `ts.Statement[]` instead of `ts.Expression`

- [ ] **`quote.type`** — Variant for type-level quasiquoting (returns `ts.TypeNode`)

- [ ] **Hygiene integration** — Generated identifiers from `quote` use `ctx.generateUniqueName()` by default; opt out with `${raw:name}` splice

- [ ] **Tests** — Cover: simple expressions, multi-statement blocks, nested quotes, type splices, spread splices, hygiene, error cases (malformed templates)

**Effort**: ~3-4 days. Core parsing + splice handling + 3 variants + tests.

**Dependencies**: None. This is pure macro infrastructure.

---

#### 1.2 Pattern-Based / Declarative Macros (`macro_rules!` equivalent)

**Inspiration**: Rust `macro_rules!`, Racket `syntax-rules`, C++ `#define`

**Problem**: Simple macros (syntactic rewrites) shouldn't require writing a full `expand()` function with AST manipulation. Need a declarative layer for the 80% case.

**Design**:

```typescript
import { defineSyntaxMacro } from "ttfx";

// Simple pattern → replacement
defineSyntaxMacro("unless", {
  pattern: "unless ($cond:expr) { $body:stmts }",
  expand: "if (!($cond)) { $body }",
});

// Multiple arms (like macro_rules!)
defineSyntaxMacro("dbg", {
  arms: [
    {
      pattern: "dbg($e:expr)",
      expand:
        "(() => { const __v = $e; console.log(`[$e] =`, __v); return __v; })()",
    },
  ],
});

// With type constraint
defineSyntaxMacro("assertType", {
  pattern: "assertType<$T:type>($e:expr)",
  expand: "$e as $T",
  validate: (ctx, captures) =>
    ctx.isAssignableTo(ctx.getTypeOf(captures.e), captures.T),
});
```

**Implementation**:

- [ ] **Pattern parser** — Parse pattern strings into a pattern AST with capture groups:
  - `$name:expr` — Captures an expression
  - `$name:stmts` — Captures statement(s)
  - `$name:ident` — Captures an identifier
  - `$name:type` — Captures a type node
  - `$name:literal` — Captures a literal
  - `$(...)*` — Repetition (zero or more)
  - `$(...)+` — Repetition (one or more)
  - File: `src/macros/syntax-macro.ts`

- [ ] **Pattern matcher** — Match a `ts.Node` against a pattern, extracting captures into a `Map<string, ts.Node | ts.Node[]>`

- [ ] **Template expander** — Substitute captures into the expansion template (reuses `quote` infrastructure from 1.1)

- [ ] **`defineSyntaxMacro()` API** — Registers a pattern-based macro in the global registry as an `ExpressionMacro` with auto-generated `expand()` function

- [ ] **Multi-arm matching** — Try arms in order, first match wins (like Rust `macro_rules!`)

- [ ] **Optional validation hook** — `validate(ctx, captures)` for type-aware checks

- [ ] **Tests** — Cover: simple rewrite, multi-arm, repetition, type captures, validation failure, ambiguous patterns

**Effort**: ~4-5 days. Pattern language design is the hard part; expansion reuses `quote`.

**Dependencies**: Benefits greatly from 1.1 (quote) for the expansion side, but can use `parseExpression()` as fallback.

---

#### 1.3 Custom Derive Macro Simplified API

**Problem**: Already in TODO (medium priority). Users need to understand `DeriveTypeInfo` internals. With `quote`, this becomes much simpler.

**Design**:

```typescript
import { defineDeriveMacro, quote } from "ttfx";

defineDeriveMacro("Printable", (ctx, typeInfo) => {
  const { name, fields } = typeInfo;
  return quote.statements`
    function print${name}(value: ${name}): string {
      return ${fields.map((f) => quote`\`${f.name}: \${value.${f.name}}\``).join(" + ', ' + ")}
    }
  `;
});
```

- [ ] **`defineDeriveMacro()` helper** — Simplified registration that wraps the user callback, handles `DeriveTypeInfo` extraction, and returns `ts.Statement[]`
- [ ] **Field iteration helpers** — `typeInfo.fields.map()` with convenient accessors
- [ ] **Documentation + examples** — Show how to write a custom derive in < 20 lines
- [ ] **Tests** — Custom derive for a user-defined trait

**Effort**: ~1-2 days (mostly API sugar over existing infrastructure).

**Dependencies**: 1.1 (quote) makes this dramatically better.

---

### Phase 2: Compile-Time Power (Unlocking New Use Cases)

These features let macros do things that are currently impossible.

#### 2.1 Compile-Time File I/O (`include!` / `embedFile`)

**Inspiration**: Rust `include_str!`/`include_bytes!`, Zig `@embedFile`, Nim `staticRead`

**Problem**: The `comptime()` sandbox blocks all I/O. But controlled, read-only file access at compile time is essential for schema-driven codegen.

**Design**:

```typescript
import { includeStr, includeBytes, includeJson } from "ttfx";

// Embed file contents as a string literal
const schema = includeStr("./schema.graphql");

// Embed as Uint8Array literal
const icon = includeBytes("./icon.png");

// Parse JSON at compile time, embed as object literal
const config = includeJson<AppConfig>("./config.json");

// Read + transform (compile-time code generation from file)
const routes = comptime(() => {
  const schema = readFile("./api-schema.yaml"); // available inside comptime
  return generateRoutes(schema);
});
```

**Implementation**:

- [ ] **`includeStr` expression macro** — Reads file relative to source file at compile time, replaces with string literal
  - File: `src/macros/include.ts`
  - Resolves path relative to `ctx.sourceFile.fileName`
  - Uses `ts.sys.readFile()` (available in the compiler host, not the vm sandbox)
  - Emits a diagnostic if file not found
  - Records file as a compilation dependency (for watch mode invalidation)

- [ ] **`includeBytes` expression macro** — Same but emits `new Uint8Array([...bytes])` literal

- [ ] **`includeJson` expression macro** — Reads JSON, parses at compile time, emits object literal AST. Supports a type parameter for validation.

- [ ] **`readFile()` in comptime sandbox** — Add a controlled `readFile(path)` function to the comptime sandbox:
  - Only reads files (no write, no network, no process)
  - Paths resolved relative to source file
  - Optional allowlist in transformer config: `{ comptimeFs: { allow: ["./schemas/**"] } }`
  - File reads are recorded as dependencies for incremental/watch invalidation

- [ ] **Dependency tracking** — Record all files read by macros so that watch mode / incremental builds know to re-expand when those files change
  - Add `ctx.recordDependency(absolutePath: string)` to `MacroContext`
  - Wire into the CLI watch mode and unplugin integration

- [ ] **Tests** — Include string, include bytes, include JSON, relative path resolution, missing file diagnostic, watch mode invalidation

**Effort**: ~3-4 days. The `includeStr`/`includeBytes`/`includeJson` macros are straightforward; the tricky part is dependency tracking for watch mode.

**Dependencies**: None (operates at the macro level, not the quote level).

---

#### 2.2 Conditional Compilation (`#[cfg]` equivalent)

**Inspiration**: Rust `#[cfg(...)]`, C `#ifdef`, Zig `@import("builtin")`

**Design**:

```typescript
import { cfg, cfgAttr } from "ttfx";

// Expression-level: evaluates to the expression or `undefined`
const debugInfo = cfg("debug", () => collectDebugInfo());

// Statement-level: entire block removed in production
cfg("debug", () => {
  console.log("Debug mode enabled");
  attachDebugger();
});

// Attribute-level: conditionally include a class member
class Server {
  @cfgAttr("test")
  mockDatabase(): Database {
    return new MockDB();
  }
}

// Complex conditions
cfg("platform.browser && !test", () => {
  initServiceWorker();
});
```

**Implementation**:

- [ ] **Configuration source** — Read conditions from:
  - `ttfx.config.ts` / `ttfx.config.json` (static config)
  - Environment variables (`TYPEMACRO_CFG_DEBUG=1`)
  - Transformer config in tsconfig.json: `{ "cfg": { "debug": true, "platform": "node" } }`

- [ ] **`cfg()` expression macro** — Evaluates condition at compile time:
  - True → replaces with the callback's return value (expanded inline)
  - False → replaces with `undefined` (or removes the statement entirely if statement-level)
  - File: `src/macros/cfg.ts`

- [ ] **`@cfgAttr()` attribute macro** — Conditionally includes/excludes decorated declarations

- [ ] **Condition language** — Simple boolean expressions over config keys:
  - `"debug"` — truthy check
  - `"!test"` — negation
  - `"platform.node"` — dotted path
  - `"debug && !production"` — boolean operators
  - `"platform == 'browser'"` — equality

- [ ] **Dead code elimination** — When `cfg` evaluates to false, the entire subtree is removed (not just replaced with `undefined`). This means imports used only in removed code should also be cleaned up.

- [ ] **Tests** — Truthy/falsy, negation, compound conditions, attribute-level, dead code removal, env var source

**Effort**: ~3 days. Condition evaluation is simple; dead code elimination and import cleanup are the fiddly parts.

**Dependencies**: None.

---

#### 2.3 Module-Graph Reflection / Auto-Registration

**Inspiration**: Zig comptime module introspection, Rust `build.rs`, Java annotation processing

**Problem**: No way to enumerate types across the project. Can't auto-register all `@route` handlers or build a DI container from type annotations.

**Design**:

```typescript
import { collectTypes, moduleIndex } from "ttfx";

// Find all classes decorated with @route in the project
const routes = collectTypes({
  decorator: "route",
  baseType: "RouteHandler",
});
// Expands to: [{ path: "/users", handler: UsersRoute }, { path: "/posts", handler: PostsRoute }]

// Generate a barrel export from a directory
const components = moduleIndex("./components/**/*.tsx");
// Expands to: export { Button } from "./components/Button"; export { Card } from "./components/Card"; ...
```

**Implementation**:

- [ ] **Multi-file analysis pass** — Before per-file transformation, scan all program source files for:
  - Decorated declarations (build a decorator → file+symbol index)
  - Exported types implementing specific interfaces
  - File: `src/transforms/project-index.ts`

- [ ] **`collectTypes()` expression macro** — Queries the project index at expansion time
  - Filters by decorator name, base type, interface implementation, file glob
  - Returns an array literal of metadata objects

- [ ] **`moduleIndex()` expression macro** — Generates barrel exports from file globs
  - Resolves globs relative to source file
  - Emits `export { Name } from "./path"` statements

- [ ] **Project index caching** — Index is built once per program, reused across files. Invalidated on watch mode file changes.

- [ ] **Tests** — Multi-file scenarios (need test harness that compiles multiple files), decorator collection, glob-based indexing

**Effort**: ~5-6 days. Multi-file analysis is architecturally significant — currently the transformer is per-file.

**Dependencies**: None, but benefits from 2.1 (dependency tracking infrastructure).

---

### Phase 3: Safety & Correctness

Making macros trustworthy for production use.

#### 3.1 Macro Hygiene System

**Inspiration**: Racket (lexical hygiene), Scheme `syntax-rules`, Sweet.js

**Problem**: Generated identifiers use `__ttfx_` prefix convention, but there's no formal system preventing capture. Complex macro compositions can collide.

**Design**:

```typescript
// Macro-generated names are automatically unique per expansion site
// This "just works" — no user action needed for the common case

// Macro author can opt into unhygienic (intentional capture):
const userVisible = ctx.createUnhygienicIdentifier("result"); // Uses the exact name "result"
const internal = ctx.generateUniqueName("temp"); // Gets "__ttfx_temp_42" (already exists)

// New: Scoped hygiene context
ctx.withHygieneScope(() => {
  // All identifiers created here are in the same scope
  // They can reference each other but won't leak
  const a = ctx.createIdentifier("x"); // Actually __ttfx_x_scope7_0
  const b = ctx.createIdentifier("x"); // Same: __ttfx_x_scope7_0 (same scope, same name)
});
```

**Implementation**:

- [ ] **Hygiene context on `MacroContext`** — Track a scope ID that increments per macro expansion
  - `ctx.withHygieneScope(fn)` — Creates a new scope; identifiers within share a namespace
  - `ctx.createIdentifier(name)` — Returns a mangled name unique to the current scope
  - `ctx.createUnhygienicIdentifier(name)` — Escapes hygiene (for intentional capture)

- [ ] **Automatic hygiene in `quote`** — Identifiers introduced by `quote` templates (not spliced in) are automatically hygienic

- [ ] **Scope chain** — Nested macro expansions get nested scopes; inner scopes can't capture outer macro-generated names

- [ ] **Unhygienic escape hatch** — `${raw:name}` in quote templates, `ctx.createUnhygienicIdentifier()` in procedural macros

- [ ] **Tests** — Name collision prevention, nested scopes, intentional capture, quote hygiene, cross-macro composition

**Effort**: ~3-4 days. The core mechanism is scope-ID-based name mangling; the complexity is in making it transparent.

**Dependencies**: 1.1 (quote) for automatic hygiene integration.

---

#### 3.2 Enhanced Diagnostics (Warnings, Suggestions, Quick-Fixes)

**Inspiration**: Rust `compile_error!`, Scala 3 `report.error`, `report.warning`

**Problem**: Macros can emit errors, but not warnings. No way to suggest fixes. Diagnostics point to macro internals, not user code.

**Implementation**:

- [ ] **`ctx.reportWarning()` already exists** — Verify it flows through TS diagnostic pipeline correctly (currently `MacroDiagnostic` has `severity: "warning"` but need to confirm it maps to `ts.DiagnosticCategory.Warning`)

- [ ] **`ctx.reportSuggestion()`** — New method for "info" level diagnostics with suggested fixes:

  ```typescript
  ctx.reportSuggestion(
    node,
    "Consider using @derive(Eq) instead of manual equality",
    {
      fix: {
        description: "Add @derive(Eq)",
        changes: [{ node, replacement: quote`@derive(Eq)` }],
      },
    },
  );
  ```

- [ ] **`staticAssert()` expression macro** — Compile-time assertion:

  ```typescript
  staticAssert(
    comptime(() => MAX_SIZE <= 1024),
    "MAX_SIZE must be <= 1024",
  );
  staticAssert<Extends<UserInput, Required<BaseSchema>>>(); // Type-level assertion
  ```

  - File: `src/macros/static-assert.ts`
  - Evaluates condition at compile time
  - Emits `ts.DiagnosticCategory.Error` with the user's message if false
  - Type-level variant checks type relationships

- [ ] **Positional diagnostics** — Ensure all macro diagnostics point to the user's source location (the macro call site), not internal macro code. Audit existing macros.

- [ ] **`compile_error!` / `compile_warning!` equivalents** — Expression macros that unconditionally emit diagnostics:

  ```typescript
  compile_error("This API is deprecated, use newApi() instead");
  compile_warning("This pattern is slow, consider using X");
  ```

- [ ] **Tests** — Warning emission, suggestion with fix, staticAssert pass/fail, positional accuracy

**Effort**: ~2-3 days. Mostly wiring existing infrastructure + new `staticAssert` macro.

**Dependencies**: None.

---

#### 3.3 Macro Capability Tracking

**Inspiration**: Scala 3 `Quotes` context, Rust proc-macro capability flags

**Problem**: All macros get the same `MacroContext` with full power. A simple string-rewriting macro shouldn't have type checker access.

**Implementation**:

- [ ] **Capability flags on `MacroDefinitionBase`**:

  ```typescript
  interface MacroDefinitionBase {
    capabilities?: {
      needsTypeChecker?: boolean; // default: false
      needsFileSystem?: boolean; // default: false (for include macros)
      needsProjectIndex?: boolean; // default: false (for collectTypes)
      canEmitDiagnostics?: boolean; // default: true
      maxTimeout?: number; // override default 5s
    };
  }
  ```

- [ ] **Restricted context variants** — When a macro declares limited capabilities, it receives a restricted `MacroContext` that throws on disallowed operations

- [ ] **Documentation** — Explain capability model in macro authoring guide

- [ ] **Tests** — Macro with restricted capabilities can't access type checker, etc.

**Effort**: ~2 days. Mostly interface design + proxy/wrapper on MacroContext.

**Dependencies**: 2.1 (file system capability), 2.3 (project index capability).

---

### Phase 4: Developer Experience

Making macros debuggable and the project usable.

#### 4.1 Macro Expansion Visualization (`cargo expand` equivalent)

**Inspiration**: Rust `cargo expand`, Scala `-Xprint:typer`, Babel `--show-ast`

**Design**:

```bash
# Show expanded output for a file
npx ttfx expand src/models/user.ts

# Show expanded output for a specific macro call (by line number)
npx ttfx expand src/models/user.ts:42

# Diff mode: show original vs expanded side-by-side
npx ttfx expand --diff src/models/user.ts

# JSON AST output (for tooling)
npx ttfx expand --ast src/models/user.ts
```

**Implementation**:

- [ ] **`expand` CLI command** — New command in `src/cli/index.ts`:
  - Creates a program, runs the transformer, prints the result
  - `--diff` flag shows unified diff between original and expanded
  - `--ast` flag outputs JSON AST
  - Line-number targeting: only show the expansion of the macro at that line
  - Syntax highlighting in terminal output (use `chalk` or similar)

- [ ] **Expansion metadata** — During transformation, record which nodes were macro-expanded:
  - Add `ctx.recordExpansion(original: ts.Node, expanded: ts.Node, macroName: string)` to `MacroContext`
  - Store in a per-file expansion map
  - Used by expand CLI, IDE hover, and debugging

- [ ] **IDE hover expansion** — In the language service plugin, show expanded code on hover over macro calls:
  - Hover over `@derive(Eq)` → tooltip shows the generated `pointEq()` function
  - Hover over `comptime(() => ...)` → tooltip shows the computed value
  - Hover over `ops(a + b)` → tooltip shows `a.add(b)`

- [ ] **Tests** — CLI expand command output, diff mode, line targeting, expansion metadata recording

**Effort**: ~3-4 days. CLI is straightforward; IDE hover integration is the polish work.

**Dependencies**: None, but benefits from expansion metadata being wired into all macros.

---

#### 4.2 Incremental Caching

**Inspiration**: Rust incremental compilation, Scala zinc, Babel cache

**Problem**: `comptime()` re-runs on every compilation. Derive macros re-expand unchanged types.

**Implementation**:

- [ ] **Content-hash cache** — Hash macro inputs (source text + type info + config) → cache expanded output:
  - File: `src/cache/expansion-cache.ts`
  - Cache key: `hash(macroName + inputSourceText + typeSignature + configHash)`
  - Cache value: serialized expanded AST (or printed source text)
  - Storage: `.ttfx-cache/` directory (gitignored)

- [ ] **Dependency-aware invalidation** — Cache entries track their dependencies:
  - Types referenced (if type changes, invalidate)
  - Files read via `includeStr` etc. (if file changes, invalidate)
  - Config values used (if config changes, invalidate)

- [ ] **Cache integration in transformer** — Before expanding a macro, check cache:

  ```
  1. Compute cache key
  2. If cache hit → deserialize and return cached AST
  3. If cache miss → expand normally, cache the result
  ```

- [ ] **Cache warming** — `npx ttfx cache-warm` pre-populates cache for CI

- [ ] **Cache stats** — `npx ttfx cache-stats` shows hit rate, size, staleness

- [ ] **Tests** — Cache hit/miss, invalidation on source change, invalidation on type change, invalidation on file dependency change

**Effort**: ~4-5 days. Hashing and serialization are the core challenges; AST serialization/deserialization needs care.

**Dependencies**: 2.1 (dependency tracking for file-based invalidation).

---

#### 4.3 Source Maps for Expanded Code

**Problem**: Already in TODO. Multi-statement expansions (derive, reflect) don't map well.

**Implementation**:

- [ ] **Expansion source map generation** — When a macro expands to multiple statements, generate a source map that maps each generated statement back to the macro invocation site
  - For derive macros: map each generated function to the `@derive(...)` decorator
  - For comptime: map the result to the `comptime(...)` call
  - For quote-generated code: map to the `quote` template

- [ ] **unplugin source map integration** — Wire expansion source maps into the unplugin `transform()` return value (it already has a TODO for this)

- [ ] **Tests** — Verify source maps point to correct locations in debugger

**Effort**: ~3 days. Source map generation is well-understood but fiddly.

**Dependencies**: None.

---

#### 4.4 Documentation Site

**Problem**: Already in TODO (high priority). No docs beyond DESIGN.md and README.

**Implementation**:

- [ ] **Choose framework** — Starlight (Astro-based), VitePress, or Docusaurus
- [ ] **Core pages**:
  - Getting Started (install, configure tsconfig, first macro)
  - Macro Types (expression, attribute, derive, tagged-template, labeled-block, type)
  - Writing Custom Macros (with `quote` and `defineSyntaxMacro`)
  - Built-in Macros Reference (comptime, derive, operators, reflect, typeclass, specialize, cfg, include)
  - Use Cases (cats, type-system, zero-cost, sql, strings, units, comprehensions)
  - API Reference (MacroContext, registry, types)
  - Architecture (how the transformer works)
  - FAQ / Troubleshooting
- [ ] **Interactive examples** — Code blocks with "show expanded" toggle
- [ ] **Deploy** — GitHub Pages or Vercel

**Effort**: ~5-7 days for comprehensive docs.

**Dependencies**: Should be done after Phase 1 (so docs cover quote/syntax macros).

---

#### 4.5 ESLint Plugin

**Problem**: Already in TODO. Common macro mistakes aren't caught by the editor.

**Implementation**:

- [ ] **`ttfx/eslint-plugin`** package with rules:
  - `no-side-effects-in-comptime` — Warn on I/O-like calls inside `comptime()`
  - `no-runtime-in-derive` — Warn on runtime code in derive macro definitions
  - `valid-derive-names` — Error on `@derive(Unknown)` with unknown derive name
  - `no-unused-macro-import` — Warn when importing a macro placeholder but never using it
  - `prefer-comptime-literal` — Suggest `comptime()` for constant expressions

- [ ] **Tests** — ESLint rule tester for each rule

**Effort**: ~3 days.

**Dependencies**: None.

---

#### 4.6 Online Playground

**Problem**: Already in TODO. ts-macros has one; we don't.

**Implementation**:

- [ ] **Monaco-based playground** — Browser-based editor with:
  - Left pane: TypeScript source with macro calls
  - Right pane: Expanded output (live)
  - Bottom pane: Diagnostics
  - Preset examples (one per use case)
  - Shareable URLs (encode source in URL hash)

- [ ] **Browser compilation** — Bundle the transformer for browser execution:
  - TypeScript compiler runs in browser (already possible)
  - Transformer runs as a plugin
  - No server needed (fully client-side)

- [ ] **Deploy** — Static site on GitHub Pages

**Effort**: ~5-7 days.

**Dependencies**: 4.4 (docs site can host it).

---

### Phase 5: Macro Composition & Advanced Features

#### 5.1 Macro Composition Pipeline

**Inspiration**: Racket macro expander, Elixir `use` macro

**Problem**: Macros can't cleanly invoke other macros. Ordering is implicit.

**Implementation**:

- [ ] **Explicit expansion ordering** — Allow macros to declare dependencies:

  ```typescript
  defineExpressionMacro({
    name: "myMacro",
    expandAfter: ["derive"], // Ensure derive runs first
    expand: (ctx, call, args) => { ... }
  });
  ```

- [ ] **Macro-generated macro invocations** — When a macro's expansion contains another macro call, the transformer re-visits the expanded nodes. Currently this works for single-pass macros; formalize and test for multi-pass scenarios.

- [ ] **Composition helpers**:

  ```typescript
  // Compose two macros: apply inner first, then outer
  const composed = composeMacros(innerMacro, outerMacro);

  // Pipeline: apply macros left to right
  const pipeline = macrosPipeline([normalize, validate, optimize]);
  ```

- [ ] **Tests** — Macro expanding into another macro, ordering guarantees, composition helpers

**Effort**: ~3-4 days.

**Dependencies**: None, but benefits from 3.1 (hygiene) for safe composition.

---

#### 5.2 WASM Sandbox for Comptime

**Inspiration**: Cloudflare Workers (V8 isolates), Deno (V8 + WASM)

**Problem**: Node's `vm` module is not a true security boundary. WASM would provide stronger isolation.

**Implementation**:

- [ ] **WASM runtime integration** — Use Wasmer or wasm-bindgen to run comptime code in a WASM sandbox
- [ ] **Fallback** — Keep `vm` as default; WASM as opt-in via config
- [ ] **Performance comparison** — Benchmark WASM vs vm for typical comptime workloads

**Effort**: ~5-7 days. WASM toolchain integration is non-trivial.

**Dependencies**: None.

---

### Phase 6: Ecosystem & Release

#### 6.1 npm Publish + GitHub Repo

- [ ] **Create GitHub repo** (public, under `dpovey` account)
- [ ] **npm publish workflow** — Automated via CI, with changelog generation (changesets or conventional commits)
- [ ] **Monorepo publish** — Publish all packages: `ttfx`, `@ttfx/core`, `@ttfx/fp`, etc.
- [ ] **Semantic versioning** — 0.x until API stabilizes

**Effort**: ~2 days.

**Dependencies**: None.

---

#### 6.2 Robustness Fixes (from existing TODO)

- [x] **Type checker call safety** — Wrapped all `getTypeAtLocation()`, `getPropertiesOfType()`, `typeToString()` calls in try-catch in `reflect.ts` (`extractInterfaceInfo`, `extractClassInfo`, `extractTypeAliasInfo`) and `macro-transformer.ts` (`extractTypeInfo`)
- [x] **Extension method `getText()` fragility** — Audited all macros for `getText()` on synthetic nodes; added `safeGetText()` helper in `reflect.ts` that falls back to `printer.printNode()` for synthetic nodes (pos === -1). Other macros (`typeclass.ts`, `specialize.ts`, `effects.ts`) only call `getText()` on original source nodes — verified safe.
- [x] **Decorator parsing silent failures** — Enhanced `parseDecorator()` to handle property access patterns (`@module.macro`, `@module.macro(args...)`). Unrecognized patterns pass through silently (correct behavior: user decorators should not trigger macro diagnostics).
- [x] **Import cleanup for namespace imports** — Verified existing logic is already conservative: namespace imports are only removed when the `"namespace"` sentinel is recorded (meaning the namespace identifier itself resolved to a macro). Non-macro property accesses on the namespace are not tracked, so the import is preserved by default.
- [x] **Test timeout flakiness** — Increased default test timeout from 10s to 30s and hook timeout from 10s to 15s. Relaxed benchmark thresholds for environment-dependent tests.

**Effort**: ~2-3 days.

**Dependencies**: None. Can be done anytime.

---

### Dependency Graph & Recommended Execution Order

```
Phase 1 (Foundation)          Phase 2 (Power)              Phase 3 (Safety)
┌─────────────┐              ┌─────────────┐              ┌─────────────┐
│ 1.1 Quote   │─────────────▶│ 2.1 File IO │─────────────▶│ 3.1 Hygiene │
│ (3-4 days)  │              │ (3-4 days)  │              │ (3-4 days)  │
└──────┬──────┘              └──────┬──────┘              └─────────────┘
       │                            │                     ┌─────────────┐
       ▼                            ▼                     │ 3.2 Diag    │
┌─────────────┐              ┌─────────────┐              │ (2-3 days)  │
│ 1.2 Syntax  │              │ 2.2 Cfg     │              └─────────────┘
│ (4-5 days)  │              │ (3 days)    │              ┌─────────────┐
└──────┬──────┘              └─────────────┘              │ 3.3 Caps    │
       │                     ┌─────────────┐              │ (2 days)    │
       ▼                     │ 2.3 ModGraph│              └─────────────┘
┌─────────────┐              │ (5-6 days)  │
│ 1.3 Derive  │              └─────────────┘
│ (1-2 days)  │
└─────────────┘

Phase 4 (DX)                 Phase 5 (Advanced)           Phase 6 (Release)
┌─────────────┐              ┌─────────────┐              ┌─────────────┐
│ 4.1 Expand  │              │ 5.1 Compose │              │ 6.1 Publish │
│ (3-4 days)  │              │ (3-4 days)  │              │ (2 days)    │
└─────────────┘              └─────────────┘              └─────────────┘
┌─────────────┐              ┌─────────────┐              ┌─────────────┐
│ 4.2 Cache   │◀─────────────│ 2.1 File IO │              │ 6.2 Robust  │
│ (4-5 days)  │              │ (dep track) │              │ (2-3 days)  │
└─────────────┘              └─────────────┘              └─────────────┘
┌─────────────┐
│ 4.3 SrcMaps │
│ (3 days)    │
└─────────────┘
┌─────────────┐
│ 4.4 Docs    │
│ (5-7 days)  │
└─────────────┘
┌─────────────┐
│ 4.5 ESLint  │
│ (3 days)    │
└─────────────┘
┌─────────────┐
│ 4.6 Play    │
│ (5-7 days)  │
└─────────────┘
```

### Suggested Sprint Plan

| Sprint       | Items                                         | Days  | Cumulative |
| ------------ | --------------------------------------------- | ----- | ---------- |
| **Sprint 1** | 1.1 Quote, 3.2 Diagnostics, 6.2 Robustness    | 8-10  | 8-10       |
| **Sprint 2** | 1.2 Syntax Macros, 1.3 Custom Derive API      | 5-7   | 13-17      |
| **Sprint 3** | 2.1 File I/O, 2.2 Conditional Compilation     | 6-7   | 19-24      |
| **Sprint 4** | 4.1 Expand CLI, 4.2 Caching                   | 7-9   | 26-33      |
| **Sprint 5** | 3.1 Hygiene, 5.1 Composition                  | 6-8   | 32-41      |
| **Sprint 6** | 2.3 Module-Graph Reflection, 3.3 Capabilities | 7-8   | 39-49      |
| **Sprint 7** | 4.4 Docs, 6.1 Publish                         | 7-9   | 46-58      |
| **Sprint 8** | 4.3 Source Maps, 4.5 ESLint, 4.6 Playground   | 11-17 | 57-75      |
| **Sprint 9** | 5.2 WASM Sandbox (stretch)                    | 5-7   | 62-82      |

**Total estimate: ~60-80 days of focused work.**

---

## Ideas / Future Directions

- **Effect integration** -- First-class support for the Effect ecosystem (Effect.gen, Layer, etc.)
- **Prisma-style schema macros** -- Generate types + runtime code from schema definitions
- **GraphQL tagged template** -- `gql` macro that validates queries against a schema at compile time
- **Pattern matching macro** -- Rust-style `match` with exhaustiveness checking
- **Async comptime** -- Allow `comptime()` to do async operations (fetch schemas, read config files) with explicit opt-in
- **Row polymorphism** -- Extensible records with compile-time row operations
- **Type providers** -- Generate types from external data sources (JSON schemas, databases, APIs) at compile time
- **Dependent types (lightweight)** -- Value-dependent types for array bounds, matrix dimensions, etc.
